From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Pancakse <pancakse@icecreammc.xyz>
Date: Fri, 18 Oct 2024 03:11:08 +0000
Subject: [PATCH] Add Ignite

 * Copyright (c) vectrix.space <https://vectrix.space/>
 * Copyright (c) contributors

diff --git a/build.gradle.kts b/build.gradle.kts
index 6310f69a72f590015ed1a3930e31874b791276a8..524cdd733830aee1ed857be9268b70d360a89d8a 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -14,7 +14,19 @@ val alsoShade: Configuration by configurations.creating
 
 dependencies {
     implementation(project(":icecream-api")) // Pufferfish // Paper // Purpur // IceCream
+
+    implementation("net.fabricmc:sponge-mixin:0.12.5+mixin.0.8.5") {
+        exclude(group = "com.google.guava")
+        exclude(group = "com.google.code.gson")
+        exclude(group = "org.ow2.asm")
+    }
+
+    implementation("io.github.llamalad7:mixinextras-common:0.3.2") {
+        exclude(group = "org.apache.commons")
+    }
+    
     // Paper start
+    implementation("net.fabricmc:access-widener:2.1.0")
     implementation("org.jline:jline-terminal-jansi:3.21.0")
     implementation("net.minecrell:terminalconsoleappender:1.3.0")
     implementation("net.kyori:adventure-text-serializer-ansi:4.17.0") // Keep in sync with adventureVersion from Paper-API build file
@@ -30,6 +42,7 @@ dependencies {
     alsoShade(log4jPlugins.output)
     implementation("io.netty:netty-codec-haproxy:4.1.97.Final") // Paper - Add support for proxy protocol
     // Paper end
+    implementation("org.tinylog:tinylog-api:2.7.0")
     implementation("org.apache.logging.log4j:log4j-iostreams:2.22.1") // Paper - remove exclusion
     implementation("org.ow2.asm:asm-commons:9.7")
     implementation("org.spongepowered:configurate-yaml:4.2.0-SNAPSHOT") // Paper - config files
@@ -63,9 +76,12 @@ dependencies {
     testImplementation("org.hamcrest:hamcrest:2.2")
     testImplementation("org.mockito:mockito-core:5.11.0")
     testImplementation("org.ow2.asm:asm-tree:9.7")
+    testImplementation("org.tinylog:tinylog-impl:2.7.0") // IceCream
     testImplementation("org.junit-pioneer:junit-pioneer:2.2.0") // Paper - CartesianTest
     implementation("net.neoforged:srgutils:1.0.9") // Paper - mappings handling
     implementation("net.neoforged:AutoRenamingTool:2.0.3") // Paper - remap plugins
+    implementation("com.google.code.gson:gson:2.11.0") // IceCream
+    implementation("com.google.guava:guava:33.3.1-jre") // IceCream
     // Paper start - Remap reflection
     val reflectionRewriterVersion = "0.0.3"
     implementation("io.papermc:reflection-rewriter:$reflectionRewriterVersion")
diff --git a/src/main/java/space/vectrix/ignite/Blackboard.java b/src/main/java/space/vectrix/ignite/Blackboard.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd70f104f7d96b76e409f4d25f56e5944e6defd9
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/Blackboard.java
@@ -0,0 +1,103 @@
+package space.vectrix.ignite;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Optional;
+import java.util.function.Supplier;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.UnknownNullability;
+import space.vectrix.ignite.util.BlackboardMap;
+
+/**
+ * Represents a map of startup flags.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class Blackboard {
+  private static final BlackboardMap BLACKBOARD = BlackboardMap.create();
+
+  // formatting:off
+  public static final BlackboardMap.@NotNull Key<Boolean> DEBUG = key("ignite.debug", Boolean.class, true);
+  public static final BlackboardMap.@NotNull Key<String> GAME_LOCATOR = key("ignite.locator", String.class, "paper");
+  public static final BlackboardMap.@NotNull Key<Path> GAME_JAR = key("ignite.jar", Path.class, Paths.get("./build/libs/icecream-paperclip-1.21.1-R0.1-SNAPSHOT.jar"));
+  public static final BlackboardMap.@NotNull Key<String> GAME_TARGET = key("ignite.target", String.class, "org.bukkit.craftbukkit.Main");
+  public static final BlackboardMap.@NotNull Key<Path> GAME_LIBRARIES = key("ignite.libraries", Path.class, Paths.get("./libraries"));
+  public static final BlackboardMap.@NotNull Key<Path> MODS_DIRECTORY = key("ignite.mods", Path.class, Paths.get("./plugins"));
+  // formatting:on
+
+  /**
+   * Returns the value associated with the {@link BlackboardMap.Key}.
+   *
+   * @param key the key
+   * @param <T> the value type
+   * @return the value
+   * @since 1.0.0
+   */
+  public static <T> @NotNull Optional<T> get(final BlackboardMap.@NotNull Key<T> key) {
+    return Blackboard.BLACKBOARD.get(key);
+  }
+
+  /**
+   * Returns the value associated with the {@link BlackboardMap.Key}.
+   *
+   * @param key the key
+   * @param <T> the value type
+   * @return the value
+   * @since 1.0.0
+   */
+  public static <T> @UnknownNullability T raw(final BlackboardMap.@NotNull Key<T> key) {
+    return Blackboard.BLACKBOARD.get(key).orElse(key.defaultValue());
+  }
+
+  /**
+   * Supplies the value associated with the {@link BlackboardMap.Key}.
+   *
+   * @param key the key
+   * @param supplier the supplier
+   * @param <T> the value type
+   * @since 1.0.0
+   */
+  public static <T> void compute(final BlackboardMap.@NotNull Key<T> key, final @NotNull Supplier<T> supplier) {
+    Blackboard.BLACKBOARD.put(key, Blackboard.supplyOrNull(supplier));
+  }
+
+  /**
+   * Sets the value associated with the {@link BlackboardMap.Key}.
+   *
+   * @param key the key
+   * @param value the value
+   * @param <T> the value type
+   * @since 1.0.0
+   */
+  public static <T> void put(final BlackboardMap.@NotNull Key<T> key, final @Nullable T value) {
+    Blackboard.BLACKBOARD.put(key, value);
+  }
+
+  /**
+   * Returns a new {@link BlackboardMap.Key} for the given key, type and
+   * default value.
+   *
+   * @param key the key
+   * @param type the type
+   * @param defaultValue the default value
+   * @param <T> the value type
+   * @return a new blackboard key
+   * @since 1.0.0
+   */
+  public static <T> BlackboardMap.@NotNull Key<T> key(final @NotNull String key, final @NotNull Class<? super T> type, final @Nullable T defaultValue) {
+    return BlackboardMap.Key.of(Blackboard.BLACKBOARD, key, type, defaultValue);
+  }
+
+  private static <T> @Nullable T supplyOrNull(final @NotNull Supplier<T> supplier) {
+    try {
+      return supplier.get();
+    } catch(final Throwable throwable) {
+      return null;
+    }
+  }
+
+  private Blackboard() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/Ignite.java b/src/main/java/space/vectrix/ignite/Ignite.java
new file mode 100644
index 0000000000000000000000000000000000000000..6760905d86ea68136cb89ae5a13dc75a13114a81
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/Ignite.java
@@ -0,0 +1,32 @@
+package space.vectrix.ignite;
+
+import org.jetbrains.annotations.NotNull;
+import space.vectrix.ignite.mod.Mods;
+
+/**
+ * Provides static access to the main functions of Ignite.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class Ignite {
+  private static Platform PLATFORM;
+
+  /* package */ static void initialize(final @NotNull Platform platform) {
+    Ignite.PLATFORM = platform;
+  }
+
+  /**
+   * Returns the {@link Mods}.
+   *
+   * @return the mods
+   * @since 1.0.0
+   */
+  public static @NotNull Mods mods() {
+    if(Ignite.PLATFORM == null) throw new IllegalStateException("Ignite has not been initialized yet!");
+    return Ignite.PLATFORM.mods();
+  }
+
+  private Ignite() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/IgniteBootstrap.java b/src/main/java/space/vectrix/ignite/IgniteBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..db7e834cde7d6401ce6eabd63d86e56f51225dc8
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/IgniteBootstrap.java
@@ -0,0 +1,209 @@
+package space.vectrix.ignite;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.*;
+import java.util.jar.*;
+import java.nio.file.*;
+import java.io.*;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.asm.util.JavaVersion;
+import org.spongepowered.asm.util.asm.ASM;
+import org.tinylog.Logger;
+import space.vectrix.ignite.agent.IgniteAgent;
+import space.vectrix.ignite.game.GameLocatorService;
+import space.vectrix.ignite.game.GameProvider;
+import space.vectrix.ignite.launch.ember.Ember;
+import space.vectrix.ignite.mod.ModsImpl;
+import space.vectrix.ignite.util.IgniteCollections;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Represents the main class which starts Ignite.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class IgniteBootstrap {
+  private static IgniteBootstrap INSTANCE;
+
+  /**
+   * Returns the bootstrap instance.
+   *
+   * @return this instance
+   * @since 1.0.0
+   */
+  public static @NotNull IgniteBootstrap instance() {
+    return IgniteBootstrap.INSTANCE;
+  }
+
+  private static File mainfile = null;
+    private static void findMainInstance(){
+        try {
+            mainfile = new File(IgniteBootstrap.class.getProtectionDomain().getCodeSource().getLocation().toURI());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+  /**
+   * The main entrypoint to start Ignite.
+   *
+   * @param arguments the launch arguments
+   * @since 1.0.0
+   */
+  public static void main(final String@NotNull [] arguments) {
+    new IgniteBootstrap().run(arguments);
+  }
+
+  private final ModsImpl engine;
+
+  public IgniteBootstrap() {
+      String javaVersion = System.getProperty("java.version");
+        Logger.info("Loading Java Version: " + javaVersion);
+
+        int majorVersion = Integer.parseInt(javaVersion.split("\\.")[0]);
+
+        if (!(majorVersion >= 21)) {
+          Logger.info("Java version is below 21, please upgrade your Java version.");
+          System.exit(1);
+        }
+      findMainInstance();
+      Path cdir = Paths.get(mainfile.getParent());
+
+      try (Stream<Path> files = Files.list(cdir)) {
+          if (mainfile != null) {
+              JarFile jar = new JarFile(mainfile);
+
+              Enumeration<JarEntry> entries = jar.entries();
+              while (entries.hasMoreElements()) {
+                  JarEntry entry = entries.nextElement();
+                  if (entry.getName().endsWith("icecream-paperclip-1.21.1-R0.1-SNAPSHOT.zip")) {
+                      Path pluginsDirectory = Paths.get(mainfile.getParent() + "/.launcher/");
+
+                      if (!Files.exists(pluginsDirectory)) {
+                          Files.createDirectories(pluginsDirectory);
+                      }
+
+                      Path destinationPath = pluginsDirectory.resolve("icecream-paperclip-1.21.1-R0.1-SNAPSHOT.jar");
+                      Files.copy(jar.getInputStream(entry), destinationPath, StandardCopyOption.REPLACE_EXISTING);
+                      break;
+                  }
+              }
+
+              jar.close();
+          } else {
+              System.err.println("No JAR file found.");
+          }
+      } catch (IOException e) {
+          e.printStackTrace();
+      }
+
+    IgniteBootstrap.INSTANCE = this;
+    this.engine = new ModsImpl();
+  }
+
+  private void run(final String@NotNull [] args) {
+    final List<String> arguments = Arrays.asList(args);
+    final List<String> launchArguments = new ArrayList<>(arguments);
+
+    // Print the runtime information for this launch.
+    Logger.info(
+      "Running {} v{} (API: {}, ASM: {}, Java: {})",
+      IgniteConstants.API_TITLE,
+      IgniteConstants.IMPLEMENTATION_VERSION,
+      IgniteConstants.API_VERSION,
+      ASM.getVersionString(),
+      JavaVersion.current()
+    );
+
+    // Initialize the blackboard and populate it with the startup
+    // flags.
+    // Blackboard.compute(Blackboard.DEBUG, () -> Boolean.parseBoolean(System.getProperty(Blackboard.DEBUG.name())));
+    // Blackboard.compute(Blackboard.GAME_LOCATOR, () -> System.getProperty(Blackboard.GAME_LOCATOR.name()));
+    // Blackboard.compute(Blackboard.GAME_JAR, () -> Paths.get(System.getProperty(Blackboard.GAME_JAR.name())));
+    // Blackboard.compute(Blackboard.GAME_TARGET, () -> System.getProperty(Blackboard.GAME_TARGET.name()));
+    // Blackboard.compute(Blackboard.GAME_LIBRARIES, () -> Paths.get(System.getProperty(Blackboard.GAME_LIBRARIES.name())));
+    // Blackboard.compute(Blackboard.MODS_DIRECTORY, () -> Paths.get(System.getProperty(Blackboard.MODS_DIRECTORY.name())));
+
+    // Get a suitable game locator and game provider.
+    final GameLocatorService gameLocator;
+    final GameProvider gameProvider;
+    {
+      final Optional<String> requiredGameLocator = Optional.of("icecream"); // IceCream
+      final ServiceLoader<GameLocatorService> gameLocatorLoader = ServiceLoader.load(GameLocatorService.class);
+      final Optional<GameLocatorService> gameLocatorProvider = requiredGameLocator.map(locatorIdentifier -> IgniteCollections.stream(gameLocatorLoader)
+        .filter(locator -> locator.id().equalsIgnoreCase(locatorIdentifier))
+        .findFirst()).orElseGet(() -> IgniteCollections.stream(gameLocatorLoader)
+        .sorted(Comparator.comparingInt(GameLocatorService::priority))
+        .filter(GameLocatorService::shouldApply)
+        .findFirst()
+      );
+
+      if(!gameLocatorProvider.isPresent()) {
+        Logger.error("Failed to start game: Unable to find a suitable GameLocator service.");
+        System.exit(1);
+        return;
+      }
+
+      gameLocator = gameLocatorProvider.get();
+
+      Logger.info("Detected game locator: {}", gameLocator.name());
+
+      try {
+        gameLocator.apply(this);
+      } catch(final Throwable throwable) {
+        Logger.error(throwable, "Failed to start game: Unable to apply GameLocator service.");
+        System.exit(1);
+        return;
+      }
+
+      gameProvider = gameLocator.locate();
+    }
+
+    Logger.info("Preparing the game...");
+
+    // Add the game.
+    final Path gameJar = Blackboard.raw(Blackboard.GAME_JAR);
+    try {
+      IgniteAgent.addJar(gameJar);
+
+      Logger.trace("Added game jar: {}", gameJar);
+    } catch(final IOException exception) {
+      Logger.error(exception, "Failed to resolve game jar: {}", gameJar);
+      System.exit(1);
+      return;
+    }
+
+    // Add the game libraries.
+    gameProvider.gameLibraries().forEach(path -> {
+      if(!path.toString().endsWith(".jar")) return;
+
+      try {
+        IgniteAgent.addJar(path);
+
+        Logger.trace("Added game library jar: {}", path);
+      } catch(final IOException exception) {
+        Logger.error(exception, "Failed to resolve game library jar: {}", path);
+      }
+    });
+
+    Logger.info("Launching the game...");
+
+    // Initialize the API.
+    Ignite.initialize(new PlatformImpl());
+
+    // Launch the game.
+    Ember.launch(launchArguments.toArray(new String[0]));
+  }
+
+  /**
+   * Returns the mod engine.
+   *
+   * @return the mod engine
+   * @since 1.0.0
+   */
+  public @NotNull ModsImpl engine() {
+    return this.engine;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/Platform.java b/src/main/java/space/vectrix/ignite/Platform.java
new file mode 100644
index 0000000000000000000000000000000000000000..f597a685b9871fb53f42fc27d38c7ab965eecbc1
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/Platform.java
@@ -0,0 +1,22 @@
+package space.vectrix.ignite;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import space.vectrix.ignite.mod.Mods;
+
+/**
+ * Provides access to the main functions of Ignite.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+@ApiStatus.NonExtendable
+public interface Platform {
+  /**
+   * Returns the {@link Mods}.
+   *
+   * @return the mods
+   * @since 1.0.0
+   */
+  @NotNull Mods mods();
+}
diff --git a/src/main/java/space/vectrix/ignite/PlatformImpl.java b/src/main/java/space/vectrix/ignite/PlatformImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..68e51922797b9fee27f8963b2ced80d7195e41e3
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/PlatformImpl.java
@@ -0,0 +1,20 @@
+package space.vectrix.ignite;
+
+import org.jetbrains.annotations.NotNull;
+import space.vectrix.ignite.mod.Mods;
+
+/**
+ * Provides the platform implementation.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class PlatformImpl implements Platform {
+  /* package */ PlatformImpl() {
+  }
+
+  @Override
+  public @NotNull Mods mods() {
+    return IgniteBootstrap.instance().engine();
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/agent/IgniteAgent.java b/src/main/java/space/vectrix/ignite/agent/IgniteAgent.java
new file mode 100644
index 0000000000000000000000000000000000000000..15dfe8bfac0926f6aab5473d21be09c0f6971335
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/agent/IgniteAgent.java
@@ -0,0 +1,87 @@
+package space.vectrix.ignite.agent;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.Instrumentation;
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Provides static access to add additional resources to the system
+ * classloader.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class IgniteAgent {
+  private static Instrumentation INSTRUMENTATION = null;
+
+  /**
+   * Adds a {@link ClassFileTransformer} to this agent.
+   *
+   * @param transformer the transformer
+   * @since 1.0.0
+   */
+  public static void addTransformer(final @NotNull ClassFileTransformer transformer) {
+    if(IgniteAgent.INSTRUMENTATION != null) IgniteAgent.INSTRUMENTATION.addTransformer(transformer);
+  }
+
+  /**
+   * Adds a jar {@link Path} to this agent.
+   *
+   * @param path the path
+   * @throws IOException if there is an error resolving the path
+   * @since 1.0.0
+   */
+  public static void addJar(final @NotNull Path path) throws IOException {
+    final File file = path.toFile();
+    if(!file.exists()) throw new FileNotFoundException(file.getAbsolutePath());
+    if(file.isDirectory() || !file.getName().endsWith(".jar")) throw new IOException("Provided path is not a jar file: " + path);
+    IgniteAgent.addJar(new JarFile(file));
+  }
+
+  /**
+   * Adds a {@link JarFile} to this agent.
+   *
+   * @param jar the jar file
+   * @since 1.0.0
+   */
+  public static void addJar(final @NotNull JarFile jar) {
+    if(IgniteAgent.INSTRUMENTATION != null) {
+      IgniteAgent.INSTRUMENTATION.appendToSystemClassLoaderSearch(jar);
+      return;
+    }
+
+    throw new IllegalStateException("Unable to addJar for '" + jar.getName() + "'.");
+  }
+
+  /**
+   * The agent premain entrypoint.
+   *
+   * @param arguments the arguments
+   * @param instrumentation the instrumentation
+   * @since 1.0.0
+   */
+  public static void premain(final @NotNull String arguments, final @Nullable Instrumentation instrumentation) {
+    IgniteAgent.agentmain(arguments, instrumentation);
+  }
+
+  /**
+   * The agent main entrypoint.
+   *
+   * @param arguments the arguments
+   * @param instrumentation the instrumentation
+   * @since 1.0.0
+   */
+  public static void agentmain(final @NotNull String arguments, final @Nullable Instrumentation instrumentation) {
+    if(IgniteAgent.INSTRUMENTATION == null) IgniteAgent.INSTRUMENTATION = instrumentation;
+    if(IgniteAgent.INSTRUMENTATION == null) throw new NullPointerException("Unable to get instrumentation instance!");
+  }
+
+  private IgniteAgent() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/agent/package-info.java b/src/main/java/space/vectrix/ignite/agent/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..e861f3cda8a4c2f9dbca3db1f4d163f26945ec0a
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/agent/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the agent.
+ */
+package space.vectrix.ignite.agent;
diff --git a/src/main/java/space/vectrix/ignite/agent/transformer/PaperclipTransformer.java b/src/main/java/space/vectrix/ignite/agent/transformer/PaperclipTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..02e586626bce3c39ed216bc8ed6464dc2753efe3
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/agent/transformer/PaperclipTransformer.java
@@ -0,0 +1,90 @@
+package space.vectrix.ignite.agent.transformer;
+
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.security.ProtectionDomain;
+import org.jetbrains.annotations.NotNull;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Provides a transformer for replacing Paperclips {@link System#exit(int)}s
+ * with returns.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class PaperclipTransformer implements ClassFileTransformer {
+  private final String target;
+
+  /**
+   * Creates a new paperclip transformer.
+   *
+   * @param target the target class
+   * @since 1.0.0
+   */
+  public PaperclipTransformer(final @NotNull String target) {
+    this.target = target;
+  }
+
+  @Override
+  public byte[] transform(final ClassLoader loader, final String className, final Class<?> classBeingRedefined,
+                          final ProtectionDomain protectionDomain, final byte[] classFileBuffer) throws IllegalClassFormatException {
+    if(!className.equals(this.target)) return null;
+    final ClassReader reader = new ClassReader(classFileBuffer);
+    final ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+    reader.accept(new PaperclipClassVisitor(writer), ClassReader.EXPAND_FRAMES);
+    return writer.toByteArray();
+  }
+
+  private static final class PaperclipClassVisitor extends ClassVisitor {
+    private PaperclipClassVisitor(final @NotNull ClassVisitor visitor) {
+      super(IgniteConstants.ASM_VERSION, visitor);
+    }
+
+    @Override
+    public MethodVisitor visitMethod(final int access, final @NotNull String name, final @NotNull String descriptor, final @NotNull String signature, final @NotNull String[] exceptions) {
+      final MethodVisitor mv = this.cv.visitMethod(access, name, descriptor, signature, exceptions);
+      return new PaperclipMethodVisitor(descriptor, mv);
+    }
+  }
+
+  private static final class PaperclipMethodVisitor extends MethodVisitor {
+    private final String descriptor;
+
+    private PaperclipMethodVisitor(final @NotNull String descriptor, final @NotNull MethodVisitor visitor) {
+      super(IgniteConstants.ASM_VERSION, visitor);
+
+      this.descriptor = descriptor;
+    }
+
+    @Override
+    public void visitMethodInsn(final int opcode, final @NotNull String owner, final @NotNull String name,
+                                final @NotNull String descriptor, final boolean isInterface) {
+      if(name.equals("setupClasspath")) {
+        super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+        // After the method is written return.
+        this.visitInsn(Opcodes.RETURN);
+        return;
+      }
+
+      // Return before system exit calls.
+      if(owner.equals("java/lang/System") && name.equals("exit")) {
+        if(this.descriptor.endsWith("V")) {
+          // Void descriptor return type, will return normally...
+          this.visitInsn(Opcodes.RETURN);
+        } else {
+          // Otherwise, return null.
+          this.visitInsn(Opcodes.ACONST_NULL);
+          this.visitInsn(Opcodes.ARETURN);
+        }
+      }
+
+      super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/agent/transformer/SpigotTransformer.java b/src/main/java/space/vectrix/ignite/agent/transformer/SpigotTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..0551734771dfa3b37cf938ffd5d629372465c2b7
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/agent/transformer/SpigotTransformer.java
@@ -0,0 +1,89 @@
+package space.vectrix.ignite.agent.transformer;
+
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.security.ProtectionDomain;
+import org.jetbrains.annotations.NotNull;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Provides a transformer for replacing Spigots {@link System#exit(int)}s
+ * with returns.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class SpigotTransformer implements ClassFileTransformer {
+  private final String target;
+
+  /**
+   * Creates a new spigot transformer.
+   *
+   * @param target the target class
+   * @since 1.0.0
+   */
+  public SpigotTransformer(final @NotNull String target) {
+    this.target = target;
+  }
+
+  @Override
+  public byte[] transform(final ClassLoader loader, final String className, final Class<?> classBeingRedefined,
+                          final ProtectionDomain protectionDomain, final byte[] classFileBuffer) throws IllegalClassFormatException {
+    if(!className.equals(this.target)) return null;
+    final ClassReader reader = new ClassReader(classFileBuffer);
+    final ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+    reader.accept(new SpigotClassVisitor(writer), ClassReader.EXPAND_FRAMES);
+    return writer.toByteArray();
+  }
+
+  private static final class SpigotClassVisitor extends ClassVisitor {
+    private SpigotClassVisitor(final ClassVisitor visitor) {
+      super(IgniteConstants.ASM_VERSION, visitor);
+    }
+
+    @Override
+    public MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {
+      final MethodVisitor mv = this.cv.visitMethod(access, name, descriptor, signature, exceptions);
+      return new SpigotMethodVisitor(descriptor, mv);
+    }
+  }
+
+  private static final class SpigotMethodVisitor extends MethodVisitor {
+    private final String descriptor;
+
+    private int index;
+
+    private SpigotMethodVisitor(final String descriptor, final MethodVisitor visitor) {
+      super(IgniteConstants.ASM_VERSION, visitor);
+
+      this.descriptor = descriptor;
+    }
+
+    @Override
+    public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+      if (owner.equals("java/io/PrintStream") && name.equals("println") && this.index++ == 1) {
+        // Return before the specified position.
+        this.visitInsn(Opcodes.RETURN);
+      }
+
+      // Return before system exit calls.
+      if(owner.equals("java/lang/System") && name.equals("exit")) {
+        if(this.descriptor.endsWith("V")) {
+          // Void descriptor return type, will return normally...
+          this.visitInsn(Opcodes.RETURN);
+        } else {
+          // Otherwise, return null.
+          this.visitInsn(Opcodes.ACONST_NULL);
+          this.visitInsn(Opcodes.ARETURN);
+        }
+      }
+
+      super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/agent/transformer/package-info.java b/src/main/java/space/vectrix/ignite/agent/transformer/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..95bddb4d0af017cfc328d0b36523d84267013b11
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/agent/transformer/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the agent transformers.
+ */
+package space.vectrix.ignite.agent.transformer;
diff --git a/src/main/java/space/vectrix/ignite/game/DummyGameLocator.java b/src/main/java/space/vectrix/ignite/game/DummyGameLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1b135c637a14d9bbb07c2c7c8620a87809791d9
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/DummyGameLocator.java
@@ -0,0 +1,77 @@
+package space.vectrix.ignite.game;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.stream.Stream;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+
+/**
+ * Provides a general game locator.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class DummyGameLocator implements GameLocatorService {
+  private DummyGameProvider provider;
+
+  @Override
+  public @NotNull String id() {
+    return "dummy";
+  }
+
+  @Override
+  public @NotNull String name() {
+    return "Dummy";
+  }
+
+  @Override
+  public int priority() {
+    return Integer.MAX_VALUE;
+  }
+
+  @Override
+  public boolean shouldApply() {
+    return true;
+  }
+
+  @Override
+  public void apply(final @NotNull IgniteBootstrap bootstrap) throws Throwable {
+    Logger.warn("Using the dummy game provider means that all the jars found in the game libraries directory");
+    Logger.warn("will be loaded into the classpath. If this causes an unexpected problem, please delete the");
+    Logger.warn("libraries directory and try launch again.");
+
+    if(this.provider == null) {
+      this.provider = new DummyGameProvider();
+    }
+  }
+
+  @Override
+  public @NotNull GameProvider locate() {
+    return this.provider;
+  }
+
+  /* package */ static final class DummyGameProvider implements GameProvider {
+    /* package */ DummyGameProvider() {
+    }
+
+    @Override
+    public @NotNull Stream<Path> gameLibraries() {
+      final Path libraryPath = Blackboard.raw(Blackboard.GAME_LIBRARIES);
+      try(final Stream<Path> stream = Files.walk(libraryPath)) {
+        return stream
+          .filter(Files::isRegularFile)
+          .filter(path -> path.getFileName().endsWith(".jar"));
+      } catch(final Throwable throwable) {
+        return Stream.empty();
+      }
+    }
+
+    @Override
+    public @NotNull Path gamePath() {
+      return Blackboard.raw(Blackboard.GAME_JAR);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/game/GameLocatorService.java b/src/main/java/space/vectrix/ignite/game/GameLocatorService.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b1ee7cf9fce73274a46c2ca96b7a9be0544bceb
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/GameLocatorService.java
@@ -0,0 +1,62 @@
+package space.vectrix.ignite.game;
+
+import org.jetbrains.annotations.NotNull;
+import space.vectrix.ignite.IgniteBootstrap;
+
+/**
+ * Represents a game locator service.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public interface GameLocatorService {
+  /**
+   * The game locator identifier.
+   *
+   * @return the identifier
+   * @since 1.0.0
+   */
+  @NotNull String id();
+
+  /**
+   * The game locator name.
+   *
+   * @return the name
+   * @since 1.0.0
+   */
+  @NotNull String name();
+
+  /**
+   * The order to try select this locator.
+   *
+   * @return the priority
+   * @since 1.0.0
+   */
+  int priority();
+
+  /**
+   * Returns {@code true} if this locator should be used, otherwise returns
+   * {@code false}.
+   *
+   * @return whether this locator should be used
+   * @since 1.0.0
+   */
+  boolean shouldApply();
+
+  /**
+   * Applies this game locator.
+   *
+   * @param bootstrap the bootstrap
+   * @throws Throwable if there is a problem applying the locator
+   * @since 1.0.0
+   */
+  void apply(final @NotNull IgniteBootstrap bootstrap) throws Throwable;
+
+  /**
+   * Returns the game resource provider.
+   *
+   * @return the game resource provider
+   * @since 1.0.0
+   */
+  @NotNull GameProvider locate();
+}
diff --git a/src/main/java/space/vectrix/ignite/game/GameProvider.java b/src/main/java/space/vectrix/ignite/game/GameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..abf5a6f6ba0a3cfdc6397d0a8f8b804ca2249373
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/GameProvider.java
@@ -0,0 +1,29 @@
+package space.vectrix.ignite.game;
+
+import java.nio.file.Path;
+import java.util.stream.Stream;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a game resource provider.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public interface GameProvider {
+  /**
+   * Returns a stream of library paths to load.
+   *
+   * @return the game library paths
+   * @since 1.0.0
+   */
+  @NotNull Stream<Path> gameLibraries();
+
+  /**
+   * Returns the game path.
+   *
+   * @return the game path
+   * @since 1.0.0
+   */
+  @NotNull Path gamePath();
+}
diff --git a/src/main/java/space/vectrix/ignite/game/LegacyPaperGameLocator.java b/src/main/java/space/vectrix/ignite/game/LegacyPaperGameLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..1564cd6d2409340383612b23464b549a839c8ccb
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/LegacyPaperGameLocator.java
@@ -0,0 +1,205 @@
+package space.vectrix.ignite.game;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.Permission;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+import space.vectrix.ignite.agent.IgniteAgent;
+import space.vectrix.ignite.util.BlackboardMap;
+
+/**
+ * Provides a game locator for Legacy Paper.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class LegacyPaperGameLocator implements GameLocatorService {
+  private static final BlackboardMap.@NotNull Key<Path> PAPER_JAR = Blackboard.key("ignite.paper.jar",Path.class, Paths.get("./paper.jar"));
+  private static final BlackboardMap.@NotNull Key<String> PAPER_TARGET = Blackboard.key("ignite.paper.target", String.class, "io.papermc.paperclip.Paperclip");
+  private static final BlackboardMap.@NotNull Key<String> PAPER_VERSION = Blackboard.key("ignite.paper.version", String.class, "1.12.2");
+
+  private LegacyPaperGameProvider provider;
+
+  @Override
+  public @NotNull String id() {
+    return "legacy_paper";
+  }
+
+  @Override
+  public @NotNull String name() {
+    return "Legacy Paper";
+  }
+
+  @Override
+  public int priority() {
+    return 100;
+  }
+
+  @Override
+  public boolean shouldApply() {
+    /*final Path path = Blackboard.raw(LegacyPaperGameLocator.PAPER_JAR);
+    try(final JarFile jarFile = new JarFile(path.toFile())) {
+      return jarFile.getJarEntry("patch.properties") != null;
+    } catch(final IOException exception) {
+      return false;
+    }*/
+    return false;
+  }
+
+  @Override
+  public void apply(final @NotNull IgniteBootstrap bootstrap) throws Throwable {
+    // Populate the blackboard.
+    Blackboard.compute(LegacyPaperGameLocator.PAPER_JAR, () -> Paths.get(System.getProperty(LegacyPaperGameLocator.PAPER_JAR.name())));
+    Blackboard.compute(LegacyPaperGameLocator.PAPER_TARGET, () -> System.getProperty(LegacyPaperGameLocator.PAPER_TARGET.name()));
+    Blackboard.compute(LegacyPaperGameLocator.PAPER_VERSION, () -> System.getProperty(LegacyPaperGameLocator.PAPER_VERSION.name()));
+
+    // Set paperclip to patch only, we launch the game ourselves.
+    System.setProperty("paperclip.patchonly", "true");
+
+    final SecurityManager original = System.getSecurityManager();
+    try {
+      // Set the security manager to a custom one for handling paperclip.
+      System.setSecurityManager(new PaperclipExitHandler());
+
+      // Add the paperclip jar.
+      try {
+        IgniteAgent.addJar(Blackboard.raw(LegacyPaperGameLocator.PAPER_JAR));
+      } catch(final IOException exception) {
+        throw new IllegalStateException("Unable to add paperclip jar to classpath!", exception);
+      }
+
+      // Run paperclip.
+      try {
+        final Class<?> paperclipClass = Class.forName(Blackboard.raw(LegacyPaperGameLocator.PAPER_TARGET));
+        paperclipClass
+          .getMethod("main", String[].class)
+          .invoke(null, (Object) new String[0]);
+      } catch(final ClassNotFoundException exception) {
+        throw new IllegalStateException("Unable to execute paperclip jar!", exception);
+      }
+    } catch(final Throwable throwable) {
+      if(throwable instanceof InvocationTargetException) {
+        final Throwable target = ((InvocationTargetException) throwable).getTargetException();
+        if(target instanceof PaperclipException) {
+          final int code = ((PaperclipException) target).code();
+          if(code != 0) throw new RuntimeException(String.format("Launcher %s stopped, with exit code: %d", this.name(), code));
+        }
+      } else {
+        throw new RuntimeException(throwable);
+      }
+    }
+
+    // Set the security manager back.
+    System.setSecurityManager(original);
+
+    // Create the game provider.
+    if(this.provider == null) {
+      this.provider = this.createProvider();
+    }
+
+    // Locate the game jar.
+    if(!Blackboard.get(Blackboard.GAME_JAR).isPresent()) {
+      Blackboard.put(Blackboard.GAME_JAR, this.provider.gamePath());
+    }
+
+    // Remove the patchonly flag.
+    System.getProperties().remove("paperclip.patchonly");
+  }
+
+  @Override
+  public @NotNull GameProvider locate() {
+    return this.provider;
+  }
+
+  private LegacyPaperGameProvider createProvider() throws Throwable {
+    String game = null;
+
+    final Path path = Blackboard.raw(LegacyPaperGameLocator.PAPER_JAR);
+    final File file = path.toFile();
+    if(!file.exists()) throw new FileNotFoundException(file.getAbsolutePath());
+    if(file.isDirectory() || !file.getName().endsWith(".jar")) throw new IOException("Provided path is not a jar file: " + path);
+
+    try(final JarFile jarFile = new JarFile(file)) {
+      if(!Blackboard.get(LegacyPaperGameLocator.PAPER_VERSION).isPresent()) {
+        // Read the patch.properties to locate the version.
+        final JarEntry entry = jarFile.getJarEntry("patch.properties");
+        if(entry != null) {
+          try(final InputStream inputStream = jarFile.getInputStream(entry); final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+            String line;
+            while((line = reader.readLine()) != null) {
+              final String[] values = line.split("=");
+
+              if(values.length >= 2 && values[0].equalsIgnoreCase("version")) {
+                game = String.format("./cache/patched_%s.jar", values[1]);
+                Logger.trace("Located paper jar from patch.properties: {}", game);
+                break;
+              }
+            }
+          }
+        }
+      }
+
+      if(game == null) {
+        final String version = Blackboard.raw(LegacyPaperGameLocator.PAPER_VERSION);
+        game = String.format("./cache/patched_%s.jar", version);
+        Logger.trace("Located paper jar from command argument: {}", game);
+      }
+    }
+
+    return new LegacyPaperGameProvider(game);
+  }
+
+  /* package */ static final class LegacyPaperGameProvider implements GameProvider {
+    private final String game;
+
+    /* package */ LegacyPaperGameProvider(final @NotNull String game) {
+      this.game = game;
+    }
+
+    @Override
+    public @NotNull Stream<Path> gameLibraries() {
+      return Stream.empty();
+    }
+
+    @Override
+    public @NotNull Path gamePath() {
+      return Paths.get(this.game);
+    }
+  }
+
+  /* package */ static class PaperclipException extends SecurityException {
+    private static final long serialVersionUID = 1;
+    private final int code;
+
+    /* package */ PaperclipException(final int code) {
+      this.code = code;
+    }
+
+    /* package */ int code() {
+      return this.code;
+    }
+  }
+
+  /* package */ static class PaperclipExitHandler extends SecurityManager {
+    @Override
+    public void checkPermission(final @NotNull Permission permission) {
+      if(!permission.getName().startsWith("exitVM")) return;
+      final int code = Integer.parseInt(permission.getName().split(Pattern.quote("."))[1]);
+      throw new PaperclipException(code);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/game/PaperGameLocator.java b/src/main/java/space/vectrix/ignite/game/PaperGameLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..836de268e9b8f94e9f497ef90c87c0a7f7aaaee4
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/PaperGameLocator.java
@@ -0,0 +1,204 @@
+package space.vectrix.ignite.game;
+
+import com.google.gson.JsonObject;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.stream.Stream;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+import space.vectrix.ignite.agent.IgniteAgent;
+import space.vectrix.ignite.agent.transformer.PaperclipTransformer;
+import space.vectrix.ignite.util.BlackboardMap;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Provides a game locator for Paper.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class PaperGameLocator implements GameLocatorService {
+  private static final BlackboardMap.@NotNull Key<Path> PAPER_JAR = Blackboard.key("ignite.paper.jar", Path.class, Paths.get("./build/src/icecream-paperclip-1.21.1-R0.1-SNAPSHOT.jar")); // IceCream
+  private static final BlackboardMap.@NotNull Key<String> PAPER_TARGET = Blackboard.key("ignite.paper.target", String.class, "io.papermc.paperclip.Paperclip");
+  private static final BlackboardMap.@NotNull Key<String> PAPER_VERSION = Blackboard.key("ignite.paper.version", String.class, "1.21.1");
+
+  private PaperGameProvider provider;
+
+  @Override
+  public @NotNull String id() {
+    return "icecream";
+  }
+
+  @Override
+  public @NotNull String name() {
+    return "IceCream";
+  }
+
+  @Override
+  public int priority() {
+    return 50;
+  }
+
+  @Override
+  public boolean shouldApply() {
+    final Path path = Blackboard.raw(PaperGameLocator.PAPER_JAR);
+    try(final JarFile jarFile = new JarFile(path.toFile())) {
+      return jarFile.getJarEntry("version.json") != null;
+    } catch(final IOException exception) {
+      return false;
+    }
+  }
+
+  @Override
+  public void apply(final @NotNull IgniteBootstrap bootstrap) throws Throwable {
+    // Populate the blackboard.
+    Blackboard.compute(PaperGameLocator.PAPER_JAR, () -> Paths.get(System.getProperty(PaperGameLocator.PAPER_JAR.name())));
+    Blackboard.compute(PaperGameLocator.PAPER_TARGET, () -> System.getProperty(PaperGameLocator.PAPER_TARGET.name()));
+    Blackboard.compute(PaperGameLocator.PAPER_VERSION, () -> System.getProperty(PaperGameLocator.PAPER_VERSION.name()));
+
+    // Add the transformer to replace the system exits.
+    IgniteAgent.addTransformer(new PaperclipTransformer(Blackboard.raw(PaperGameLocator.PAPER_TARGET).replace('.', '/')));
+
+    // Set paperclip to patch only, we launch the game ourselves.
+    System.setProperty("paperclip.patchonly", "true");
+
+    // Add the paperclip jar.
+    try {
+      IgniteAgent.addJar(Blackboard.raw(PaperGameLocator.PAPER_JAR));
+    } catch(final IOException exception) {
+      throw new IllegalStateException("Unable to add paperclip jar to classpath!", exception);
+    }
+
+    // Run paperclip.
+    try {
+      final Class<?> paperclipClass = Class.forName(Blackboard.raw(PaperGameLocator.PAPER_TARGET));
+      paperclipClass
+        .getMethod("main", String[].class)
+        .invoke(null, (Object) new String[0]);
+    } catch(final ClassNotFoundException exception) {
+      throw new IllegalStateException("Unable to execute paperclip jar!", exception);
+    }
+
+    // Create the game provider.
+    if(this.provider == null) {
+      this.provider = this.createProvider();
+    }
+
+    // Locate the game jar.
+    if(!Blackboard.get(Blackboard.GAME_JAR).isPresent()) {
+      Blackboard.put(Blackboard.GAME_JAR, this.provider.gamePath());
+    }
+
+    // Remove the patchonly flag.
+    System.getProperties().remove("paperclip.patchonly");
+  }
+
+  @Override
+  public @NotNull GameProvider locate() {
+    return this.provider;
+  }
+
+  private PaperGameProvider createProvider() throws Throwable {
+    // Extract game information from paperclip.
+    final List<String> libraries = new ArrayList<>();
+    String game = null;
+
+    final Path path = Blackboard.raw(PaperGameLocator.PAPER_JAR);
+    final File file = path.toFile();
+    if(!file.exists()) throw new FileNotFoundException(file.getAbsolutePath());
+    if(file.isDirectory() || !file.getName().endsWith(".jar")) throw new IOException("Provided path is not a jar file: " + path);
+
+    try(final JarFile jarFile = new JarFile(file)) {
+      // Determine where the game jar is located.
+      {
+        if(!Blackboard.get(PaperGameLocator.PAPER_VERSION).isPresent()) {
+          // Read the version.list for the game to launch.
+          JarEntry entry = jarFile.getJarEntry("META-INF/versions.list");
+          if(entry != null) {
+            try(final InputStream inputStream = jarFile.getInputStream(entry); final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+              String line;
+              while((line = reader.readLine()) != null) {
+                final String[] values = line.split("\t");
+
+                if(values.length >= 3) {
+                  game = String.format("./versions/%s", values[2]);
+                  Logger.trace("Located paper jar from versions.list: {}", game);
+                  break;
+                }
+              }
+            }
+          }
+
+          // Read the version.json if the version.list is not specifically set.
+          entry = jarFile.getJarEntry("version.json");
+          if(game == null && entry != null) {
+            final InputStream inputStream = jarFile.getInputStream(entry);
+            final JsonObject versionObject = IgniteConstants.GSON.fromJson(new InputStreamReader(inputStream), JsonObject.class);
+
+            final String version = versionObject.getAsJsonPrimitive("id").getAsString();
+            game = String.format("./versions/%s/paper-%s.jar", version, version);
+            Logger.trace("Located paper jar from version.json: {}", game);
+          }
+        }
+
+        if(game == null) {
+          final String version = Blackboard.raw(PaperGameLocator.PAPER_VERSION);
+          game = String.format("./versions/%s/paper-%s.jar", version, version);
+          Logger.trace("Located paper jar from command argument: {}", game);
+        }
+      }
+
+      // Read the libraries the game should launch with.
+      {
+        final JarEntry entry = jarFile.getJarEntry("META-INF/libraries.list");
+        if(entry != null) {
+          try(final InputStream inputStream = jarFile.getInputStream(entry); final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+            String line;
+            while((line = reader.readLine()) != null) {
+              final String[] values = line.split("\t");
+
+              if(values.length >= 3) {
+                libraries.add(values[2]);
+              }
+            }
+          }
+        }
+      }
+    }
+
+    return new PaperGameProvider(game, libraries);
+  }
+
+  /* package */ static final class PaperGameProvider implements GameProvider {
+    private final List<String> libraries;
+    private final String game;
+
+    /* package */ PaperGameProvider(final @NotNull String game, final @NotNull List<String> libraries) {
+      this.game = game;
+      this.libraries = libraries;
+    }
+
+    @Override
+    public @NotNull Stream<Path> gameLibraries() {
+      final Path libraryPath = Blackboard.raw(Blackboard.GAME_LIBRARIES);
+      return this.libraries.stream().map(libraryPath::resolve);
+    }
+
+    @Override
+    public @NotNull Path gamePath() {
+      return Paths.get(this.game);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/game/SpigotGameLocator.java b/src/main/java/space/vectrix/ignite/game/SpigotGameLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..628a4b255ad8747f3f2642f77d6f3047a36513e8
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/SpigotGameLocator.java
@@ -0,0 +1,215 @@
+package space.vectrix.ignite.game;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.stream.Stream;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+import space.vectrix.ignite.agent.IgniteAgent;
+import space.vectrix.ignite.agent.transformer.SpigotTransformer;
+import space.vectrix.ignite.util.BlackboardMap;
+
+/**
+ * Provides a game locator for Spigot.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class SpigotGameLocator implements GameLocatorService {
+  private static final BlackboardMap.@NotNull Key<Path> SPIGOT_BUNDLER = Blackboard.key("ignite.spigot.bundler", Path.class, Paths.get("./bundler"));
+  private static final BlackboardMap.@NotNull Key<Path> SPIGOT_JAR = Blackboard.key("ignite.spigot.jar", Path.class, Paths.get("./spigot.jar"));
+  private static final BlackboardMap.@NotNull Key<String> SPIGOT_TARGET = Blackboard.key("ignite.spigot.target", String.class, "org.bukkit.craftbukkit.bootstrap.Main");
+  private static final BlackboardMap.@NotNull Key<String> SPIGOT_VERSION = Blackboard.key("ignite.spigot.version", String.class, "1.21.1-R0.1-SNAPSHOT");
+
+  private static final String SPIGOT_VERSION_PATTERN = "META-INF/versions/[^/].[^/]+\\.jar";
+
+  private SpigotGameProvider provider;
+
+  @Override
+  public @NotNull String id() {
+    return "spigot";
+  }
+
+  @Override
+  public @NotNull String name() {
+    return "Spigot";
+  }
+
+  @Override
+  public int priority() {
+    return 50;
+  }
+
+  @Override
+  public boolean shouldApply() {
+    /*final Path path = Blackboard.raw(SpigotGameLocator.SPIGOT_JAR);
+    try(final JarFile jarFile = new JarFile(path.toFile())) {
+      final Enumeration<JarEntry> entries = jarFile.entries();
+      while(entries.hasMoreElements()) {
+        final JarEntry entry = entries.nextElement();
+        Logger.trace("Found entry: {}", entry.getName());
+        if(entry.getName().matches(SpigotGameLocator.SPIGOT_VERSION_PATTERN)) {
+          return true;
+        }
+      }
+
+      return false;
+    } catch(final IOException exception) {
+      return false;
+    }*/
+    return false;
+  }
+
+  @Override
+  public void apply(final @NotNull IgniteBootstrap bootstrap) throws Throwable {
+    // Populate the blackboard.
+    Blackboard.compute(SpigotGameLocator.SPIGOT_BUNDLER, () -> Paths.get(System.getProperty(SpigotGameLocator.SPIGOT_BUNDLER.name())));
+    Blackboard.compute(SpigotGameLocator.SPIGOT_JAR, () -> Paths.get(System.getProperty(SpigotGameLocator.SPIGOT_JAR.name())));
+    Blackboard.compute(SpigotGameLocator.SPIGOT_TARGET, () -> System.getProperty(SpigotGameLocator.SPIGOT_TARGET.name()));
+    Blackboard.compute(SpigotGameLocator.SPIGOT_VERSION, () -> System.getProperty(SpigotGameLocator.SPIGOT_VERSION.name()));
+
+    // Add the transformer to replace the system exits.
+    IgniteAgent.addTransformer(new SpigotTransformer(Blackboard.raw(SpigotGameLocator.SPIGOT_TARGET).replace('.', '/')));
+
+    // Clear the bundler main class, we launch the game ourselves.
+    System.setProperty("bundlerMainClass", "");
+
+    // Add the spigot jar.
+    try {
+      IgniteAgent.addJar(Blackboard.raw(SpigotGameLocator.SPIGOT_JAR));
+    } catch(final IOException exception) {
+      throw new IllegalStateException("Unable to add spigot jar to classpath!", exception);
+    }
+
+    // Run spigot.
+    try {
+      final Class<?> spigotClass = Class.forName(Blackboard.raw(SpigotGameLocator.SPIGOT_TARGET));
+      spigotClass
+        .getMethod("main", String[].class)
+        .invoke(null, (Object) new String[0]);
+    } catch(final ClassNotFoundException exception) {
+      throw new IllegalStateException("Unable to execute spigot jar!", exception);
+    }
+
+    // Create the game provider.
+    if(this.provider == null) {
+      this.provider = this.createProvider();
+    }
+
+    // Locate the game jar.
+    if(!Blackboard.get(Blackboard.GAME_JAR).isPresent()) {
+      Blackboard.put(Blackboard.GAME_JAR, this.provider.gamePath());
+    }
+
+    // Remove the bundler main class flag.
+    System.getProperties().remove("bundlerMainClass");
+  }
+
+  @Override
+  public @NotNull GameProvider locate() {
+    return this.provider;
+  }
+
+  private SpigotGameProvider createProvider() throws Throwable {
+    // Extract game information from spigot.
+    final List<String> libraries = new ArrayList<>();
+    String game = null;
+
+    final Path path = Blackboard.raw(SpigotGameLocator.SPIGOT_JAR);
+    final File file = path.toFile();
+    if(!file.exists()) throw new FileNotFoundException(file.getAbsolutePath());
+    if(file.isDirectory() || !file.getName().endsWith(".jar")) throw new IOException("Provided path is not a jar file: " + path);
+
+    try(final JarFile jarFile = new JarFile(file)) {
+      // Determine where the game jar is located.
+      {
+        if(!Blackboard.get(SpigotGameLocator.SPIGOT_VERSION).isPresent()) {
+          // Read the version.list for the game to launch.
+          final JarEntry entry = jarFile.getJarEntry("META-INF/versions.list");
+          if(entry != null) {
+            try(final InputStream inputStream = jarFile.getInputStream(entry); final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+              String line;
+              while((line = reader.readLine()) != null) {
+                final String[] values = line.split(" \\*");
+
+                if(values.length >= 2) {
+                  game = String.format("./versions/%s", values[1]);
+                  Logger.trace("Located spigot jar from versions.list: {}", game);
+                  break;
+                }
+              }
+            }
+          }
+        }
+
+        if(game == null) {
+          final String version = Blackboard.raw(SpigotGameLocator.SPIGOT_VERSION);
+          game = String.format("./versions/spigot-%s.jar", version);
+          Logger.trace("Located paper jar from command argument: {}", game);
+        }
+      }
+
+      // Read the libraries the game should launch with.
+      {
+        final JarEntry entry = jarFile.getJarEntry("META-INF/libraries.list");
+        if(entry != null) {
+          try(final InputStream inputStream = jarFile.getInputStream(entry); final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
+            String line;
+            while((line = reader.readLine()) != null) {
+              final String[] values = line.split(" \\*");
+
+              if(values.length >= 2) {
+                final String value = values[1];
+
+                // Spigot doesn't actually store the minecraft server in the
+                // library directory. So we need to skip it.
+                if(value.startsWith("minecraft-server-")) continue;
+
+                libraries.add(values[1]);
+              }
+            }
+          }
+        }
+      }
+    }
+
+    return new SpigotGameProvider(libraries, game);
+  }
+
+  /* package */ static final class SpigotGameProvider implements GameProvider {
+    private final List<String> libraries;
+    private final String game;
+
+    /* package */ SpigotGameProvider(final @NotNull List<String> libraries, final @NotNull String game) {
+      this.libraries = libraries;
+      this.game = game;
+    }
+
+    @Override
+    public @NotNull Stream<Path> gameLibraries() {
+      final Path libraryPath = Blackboard.raw(SpigotGameLocator.SPIGOT_BUNDLER)
+        .resolve(Blackboard.raw(Blackboard.GAME_LIBRARIES).getFileName());
+
+      return this.libraries.stream().map(libraryPath::resolve);
+    }
+
+    @Override
+    public @NotNull Path gamePath() {
+      final Path bundlePath = Blackboard.raw(SpigotGameLocator.SPIGOT_BUNDLER);
+      return bundlePath.resolve(this.game);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/game/package-info.java b/src/main/java/space/vectrix/ignite/game/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..375c8d48230faaa07c1f199c49af067e514234d7
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/game/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * Game specific providers.
+ */
+package space.vectrix.ignite.game;
diff --git a/src/main/java/space/vectrix/ignite/launch/LaunchImpl.java b/src/main/java/space/vectrix/ignite/launch/LaunchImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..86cb530aad9a63101058c5a9037d273bb5f4e2f6
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/LaunchImpl.java
@@ -0,0 +1,189 @@
+package space.vectrix.ignite.launch;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.JarURLConnection;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+import java.util.stream.Collectors;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+import space.vectrix.ignite.launch.ember.EmberClassLoader;
+import space.vectrix.ignite.launch.ember.EmberTransformer;
+import space.vectrix.ignite.launch.ember.LaunchService;
+import space.vectrix.ignite.mod.ModResource;
+import space.vectrix.ignite.mod.ModResourceLocator;
+import space.vectrix.ignite.mod.ModsImpl;
+import space.vectrix.ignite.util.ClassLoaders;
+import space.vectrix.ignite.util.IgniteExclusions;
+
+/**
+ * Provides the launch handling for Ignite to Ember.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class LaunchImpl implements LaunchService {
+  private static final String JAVA_HOME = System.getProperty("java.home");
+  private static final @SuppressWarnings("OptionalUsedAsFieldOrParameterType") Optional<Manifest> DEFAULT_MANIFEST = Optional.of(new Manifest());
+
+  private final ConcurrentMap<String, Optional<Manifest>> manifests = new ConcurrentHashMap<>();
+
+  @Override
+  public void initialize() {
+    // Initialize the mod engine.
+    final ModsImpl engine = IgniteBootstrap.instance().engine();
+    if(engine.locateResources()) {
+      final Set<String> names = engine.resolveResources().stream()
+        .map(Map.Entry::getKey)
+        .collect(Collectors.toSet());
+
+      Logger.info("Found {} mod(s): {}", names.size(), String.join(", ", names));
+    }
+  }
+
+  @Override
+  public void configure(final @NotNull EmberClassLoader classLoader, final @NotNull EmberTransformer transformer) {
+    for(final URL url : ClassLoaders.systemClassPaths()) {
+      try {
+        final URI uri = url.toURI();
+        if(!this.transformable(uri)) {
+          Logger.debug("Skipped adding transformation path for: {}", url);
+          continue;
+        }
+
+        classLoader.addTransformationPath(Paths.get(url.toURI()));
+        Logger.debug("Added transformation path for: {}", url);
+      } catch(final URISyntaxException | IOException exception) {
+        Logger.error(exception, "Failed to add transformation path for: {}", url);
+      }
+    }
+
+    classLoader.addTransformationFilter(this.transformationFilter());
+    classLoader.addManifestLocator(this.manifestLocator());
+  }
+
+  @Override
+  public void prepare(final @NotNull EmberTransformer transformer) {
+    final ModsImpl engine = IgniteBootstrap.instance().engine();
+
+    // Resolve the wideners.
+    engine.resolveWideners(transformer);
+
+    // Resolve the mixins.
+    engine.resolveMixins();
+  }
+
+  @Override
+  public @NotNull Callable<Void> launch(final @NotNull String@NotNull [] arguments, final @NotNull EmberClassLoader loader) {
+    return () -> {
+      final Path gameJar = Blackboard.raw(Blackboard.GAME_JAR);
+      final String gameTarget = Blackboard.raw(Blackboard.GAME_TARGET);
+      if(gameJar != null && Files.exists(gameJar)) {
+        // Invoke the main method.
+        Class.forName(gameTarget, true, loader)
+          .getMethod("main", String[].class)
+          .invoke(null, (Object) arguments);
+      } else {
+        throw new IllegalStateException("No game jar was found to launch!");
+      }
+
+      return null;
+    };
+  }
+
+  private @NotNull Predicate<String> transformationFilter() {
+    return name -> {
+      for(final String test : IgniteExclusions.TRANSFORMATION_EXCLUDED_PACKAGES) {
+        if(name.startsWith(test)) {
+          return false;
+        }
+      }
+
+      return true;
+    };
+  }
+
+  private @NotNull Function<URLConnection, Optional<Manifest>> manifestLocator() {
+    final ModsImpl engine = IgniteBootstrap.instance().engine();
+
+    return connection -> {
+      if(connection instanceof JarURLConnection) {
+        final URL url = ((JarURLConnection) connection).getJarFileURL();
+        final Optional<Manifest> manifest = this.manifests.computeIfAbsent(url.toString(), key -> {
+          for(final ModResource resource : engine.resources()) {
+            if(!resource.locator().equals(ModResourceLocator.JAVA_LOCATOR)) {
+              continue;
+            }
+
+            try {
+              if(resource.path().toAbsolutePath().normalize().equals(Paths.get(url.toURI()).toAbsolutePath().normalize())) {
+                return Optional.ofNullable(resource.manifest());
+              }
+            } catch(final URISyntaxException exception) {
+              Logger.error(exception, "Failed to load manifest from jar: {}", url);
+            }
+          }
+
+          return LaunchImpl.DEFAULT_MANIFEST;
+        });
+
+        try {
+          if(manifest == LaunchImpl.DEFAULT_MANIFEST) {
+            return Optional.ofNullable(((JarURLConnection) connection).getManifest());
+          } else {
+            return manifest;
+          }
+        } catch(final IOException exception) {
+          Logger.error(exception, "Failed to load manifest from connection for: {}", url);
+        }
+      }
+
+      return Optional.empty();
+    };
+  }
+
+  private boolean transformable(final @NotNull URI uri) throws URISyntaxException, IOException {
+    final File target = new File(uri);
+
+    // Ensure JVM internals are not transformable.
+    if(target.getAbsolutePath().startsWith(LaunchImpl.JAVA_HOME)) {
+      return false;
+    }
+
+    if(target.isDirectory()) {
+      for(final String test : IgniteExclusions.TRANSFORMATION_EXCLUDED_PATHS) {
+        if(new File(target, test).exists()) {
+          return false;
+        }
+      }
+    } else if(target.isFile()) {
+      try(final JarFile jarFile = new JarFile(new File(uri))) {
+        for(final String test : IgniteExclusions.TRANSFORMATION_EXCLUDED_PATHS) {
+          if(jarFile.getEntry(test) != null) {
+            return false;
+          }
+        }
+      }
+    }
+
+    return true;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/MixinBlackboardImpl.java b/src/main/java/space/vectrix/ignite/launch/MixinBlackboardImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..6dc1ebc85aae3357efb647b94919f34f96b5cfd0
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/MixinBlackboardImpl.java
@@ -0,0 +1,55 @@
+package space.vectrix.ignite.launch;
+
+import java.util.HashMap;
+import java.util.Map;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.asm.service.IGlobalPropertyService;
+import org.spongepowered.asm.service.IPropertyKey;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.util.BlackboardMap;
+
+/**
+ * Represents the mixin blackboard provider.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class MixinBlackboardImpl implements IGlobalPropertyService {
+  private final Map<String, IPropertyKey> keys = new HashMap<>();
+
+  @Override
+  public IPropertyKey resolveKey(final @NotNull String name) {
+    return this.keys.computeIfAbsent(name, key -> new Key<>(key, Object.class));
+  }
+
+  @Override
+  public <T> T getProperty(final @NotNull IPropertyKey key) {
+    return this.getProperty(key, null);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public void setProperty(final @NotNull IPropertyKey key, final @NotNull Object other) {
+    Blackboard.put(((Key<Object>) key).key, other);
+  }
+
+  @Override
+  public @Nullable String getPropertyString(final @NotNull IPropertyKey key, final @Nullable String defaultValue) {
+    return this.getProperty(key, defaultValue);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public <T> @Nullable T getProperty(final @NotNull IPropertyKey key, final @Nullable T defaultValue) {
+    return Blackboard.get(((Key<T>) key).key).orElse(defaultValue);
+  }
+
+  private static class Key<V> implements IPropertyKey {
+    private final BlackboardMap.Key<V> key;
+
+    /* package */ Key(final @NotNull String name, final @NotNull Class<V> clazz) {
+      this.key = Blackboard.key(name, clazz, null);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/DummyClassLoader.java b/src/main/java/space/vectrix/ignite/launch/ember/DummyClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e7aa27a4153b177ea27a1d51200777f6ac18624
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/DummyClassLoader.java
@@ -0,0 +1,41 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/* package */ final class DummyClassLoader extends ClassLoader {
+  private static final Enumeration<URL> NULL_ENUMERATION = new Enumeration<URL>() {
+    @Override
+    public boolean hasMoreElements() {
+      return false;
+    }
+
+    @Override
+    public @NotNull URL nextElement() {
+      throw new NoSuchElementException();
+    }
+  };
+
+  static {
+    ClassLoader.registerAsParallelCapable();
+  }
+
+  @Override
+  protected @NotNull Class<?> loadClass(final @NotNull String name, final boolean resolve) throws ClassNotFoundException {
+    throw new ClassNotFoundException(name);
+  }
+
+  @Override
+  public @Nullable URL getResource(final @NotNull String name) {
+    return null;
+  }
+
+  @Override
+  public @NotNull Enumeration<URL> getResources(final @NotNull String name) throws IOException {
+    return DummyClassLoader.NULL_ENUMERATION;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/Ember.java b/src/main/java/space/vectrix/ignite/launch/ember/Ember.java
new file mode 100644
index 0000000000000000000000000000000000000000..175981519fcf213369ae184e578ccb05a1e673e5
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/Ember.java
@@ -0,0 +1,107 @@
+package space.vectrix.ignite.launch.ember;
+
+import com.llamalad7.mixinextras.MixinExtrasBootstrap;
+import java.lang.reflect.Method;
+import java.util.ServiceLoader;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.asm.launch.MixinBootstrap;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.tinylog.Logger;
+import space.vectrix.ignite.util.IgniteCollections;
+
+/**
+ * Represents the transformation launcher.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class Ember {
+  /**
+   * The main entrypoint to launch Ember.
+   *
+   * @param arguments the launch arguments
+   * @since 1.0.0
+   */
+  public static void launch(final String@NotNull [] arguments) {
+    new Ember().run(arguments);
+  }
+
+  /* package */ static @NotNull Ember instance() {
+    if(Ember.INSTANCE == null) throw new IllegalStateException("Instance is only available after launch!");
+    return Ember.INSTANCE;
+  }
+
+  private static Ember INSTANCE;
+
+  private final ServiceLoader<LaunchService> serviceLoader = ServiceLoader.load(LaunchService.class, Ember.class.getClassLoader());
+  private final LaunchService service;
+
+  private EmberTransformer transformer;
+  private EmberClassLoader loader;
+
+  private Ember() {
+    Ember.INSTANCE = this;
+    this.service = IgniteCollections.firstOrNull(this.serviceLoader.iterator());
+  }
+
+  /* package */ @NotNull EmberTransformer transformer() {
+    return this.transformer;
+  }
+
+  /* package */ @NotNull EmberClassLoader loader() {
+    return this.loader;
+  }
+
+  private void run(final String@NotNull [] arguments) {
+    if(this.service == null) throw new IllegalStateException("Failed to find launch service!");
+
+    // Initialize the launch.
+    this.service.initialize();
+
+    // Create the transformer.
+    this.transformer = new EmberTransformer();
+
+    // Create the class loader.
+    this.loader = new EmberClassLoader(this.transformer);
+    Thread.currentThread().setContextClassLoader(this.loader);
+
+    // Configure the class loader.
+    this.service.configure(this.loader, this.transformer);
+
+    // Start the mixin bootstrap.
+    MixinBootstrap.init();
+
+    // Prepare the launch.
+    this.service.prepare(this.transformer);
+
+    // Complete the mixin bootstrap.
+    this.completeMixinBootstrap();
+
+    // Initialize mixin extras.
+    MixinExtrasBootstrap.init();
+
+    // Execute the launch.
+    try {
+      this.service.launch(arguments, this.loader).call();
+    } catch(final Exception exception) {
+      Logger.error(exception, "Failed to launch the game!");
+    }
+  }
+
+  private void completeMixinBootstrap() {
+    // Move to the default phase.
+    try {
+      final Method method = MixinEnvironment.class.getDeclaredMethod("gotoPhase", MixinEnvironment.Phase.class);
+      method.setAccessible(true);
+      method.invoke(null, MixinEnvironment.Phase.INIT);
+      method.invoke(null, MixinEnvironment.Phase.DEFAULT);
+    } catch(final Exception exception) {
+      Logger.error(exception, "Failed to complete mixin bootstrap!");
+    }
+
+    // Initialize the mixin transformer now mixin is in the correct state.
+    for(final TransformerService transformer : this.transformer.transformers()) {
+      transformer.prepare();
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberClassLoader.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..8184927d10a37195b09f9c788012f3b14e8ca3f0
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberClassLoader.java
@@ -0,0 +1,368 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.JarURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.net.URLConnection;
+import java.nio.file.Path;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.jar.Attributes;
+import java.util.jar.Manifest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.tinylog.Logger;
+
+import static java.util.Objects.requireNonNull;
+
+/**
+ * Represents the transformation class loader.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class EmberClassLoader extends ClassLoader {
+  private static final class DynamicClassLoader extends URLClassLoader {
+    static {
+      ClassLoader.registerAsParallelCapable();
+    }
+
+    /* package */ DynamicClassLoader(final URL @NotNull [] urls) {
+      super(urls, new DummyClassLoader());
+    }
+
+    @Override
+    public void addURL(final @NotNull URL url) {
+      super.addURL(url);
+    }
+
+    @Override
+    public @Nullable Package getPackage(final @NotNull String name) {
+      return super.getPackage(name);
+    }
+
+    @Override
+    public Package@NotNull [] getPackages() {
+      return super.getPackages();
+    }
+  }
+
+  private static final List<String> EXCLUDE_PACKAGES = Arrays.asList(
+    "java.", "javax.", "com.sun.", "org.objectweb.asm."
+  );
+
+  static {
+    ClassLoader.registerAsParallelCapable();
+  }
+
+  private final Object lock = new Object();
+
+  private final ClassLoader parent;
+  private final DynamicClassLoader dynamic;
+  private final EmberTransformer transformer;
+
+  private Function<URLConnection, Manifest> manifestLocator;
+  private Predicate<String> transformationFilter;
+
+  /* package */ EmberClassLoader(final @NotNull EmberTransformer transformer) {
+    super(new DynamicClassLoader(new URL[0]));
+
+    this.parent = EmberClassLoader.class.getClassLoader();
+    this.dynamic = (DynamicClassLoader) this.getParent();
+
+    this.transformer = transformer;
+
+    this.manifestLocator = connection -> this.locateManifest(connection).orElse(null);
+    this.transformationFilter = name -> EmberClassLoader.EXCLUDE_PACKAGES.stream().noneMatch(name::startsWith);
+  }
+
+  /**
+   * Adds additional transformation paths.
+   *
+   * @param path a transformation path
+   * @since 1.0.0
+   */
+  public void addTransformationPath(final @NotNull Path path) {
+    try {
+      this.dynamic.addURL(path.toUri().toURL());
+    } catch(final MalformedURLException exception) {
+      Logger.error(exception, "Failed to resolve transformation path: {}", path);
+    }
+  }
+
+  /**
+   * Add the manifest locator.
+   *
+   * @param manifestLocator the manifest locator
+   * @since 1.0.0
+   */
+  public void addManifestLocator(final @NotNull Function<URLConnection, Optional<Manifest>> manifestLocator) {
+    requireNonNull(manifestLocator, "manifestLocator");
+    this.manifestLocator = this.alternate(manifestLocator, this::locateManifest);
+  }
+
+  /**
+   * Add the transformation filter.
+   *
+   * @param transformationFilter a transformation filter
+   * @since 1.0.0
+   */
+  public void addTransformationFilter(final @NotNull Predicate<String> transformationFilter) {
+    requireNonNull(transformationFilter, "targetPackageFilter");
+    this.transformationFilter = this.transformationFilter.and(transformationFilter);
+  }
+
+  //<editor-fold desc="Classes">
+  /* package */ boolean hasClass(final @NotNull String name) {
+    final String canonicalName = name.replace('/', '.');
+    return this.findLoadedClass(canonicalName) != null;
+  }
+
+  @Override
+  protected @NotNull Class<?> loadClass(final @NotNull String name, final boolean resolve) throws ClassNotFoundException {
+    synchronized(this.getClassLoadingLock(name)) {
+      final String canonicalName = name.replace('/', '.');
+
+      Class<?> target = this.findLoadedClass(canonicalName);
+      if(target == null) {
+        if(canonicalName.startsWith("java.")) {
+          Logger.trace("Loading parent class: {}", canonicalName);
+          target = this.parent.loadClass(canonicalName);
+          Logger.trace("Loaded parent class: {}", canonicalName);
+        } else {
+          Logger.trace("Attempting to load class: {}", canonicalName);
+          target = this.findClass(canonicalName, TransformPhase.INITIALIZE);
+          if(target == null) {
+            Logger.trace("Unable to locate class: {}", canonicalName);
+            final String internalName = canonicalName.replace('.', '/').concat(".class");
+            final URL url = this.parent.getResource(internalName);
+
+            if(url != null) {
+              Logger.trace("Attempting to load parent class: {}", canonicalName);
+              target = this.parent.loadClass(canonicalName);
+              Logger.trace("Loaded parent class: {}", canonicalName);
+            } else {
+              Logger.trace("Unable to locate parent resource: {}", canonicalName);
+              throw new ClassNotFoundException("Unable to locate parent resource: " + canonicalName);
+            }
+          } else {
+            Logger.trace("Loaded transformed class: {}", canonicalName);
+          }
+        }
+      }
+
+      if(resolve) this.resolveClass(target);
+      return target;
+    }
+  }
+
+  @Override
+  protected @NotNull Class<?> findClass(final @NotNull String name) throws ClassNotFoundException {
+    Logger.trace("Finding class: {}", name);
+    final Class<?> target = this.findClass(name, TransformPhase.INITIALIZE);
+    if(target == null) {
+      Logger.trace("Unable to find class: {}", name);
+      throw new ClassNotFoundException(name);
+    }
+
+    Logger.trace("Found class: {}", name);
+    return target;
+  }
+
+  /* package */ @Nullable Class<?> findClass(final @NotNull String name, final @NotNull TransformPhase phase) {
+    final String canonicalName = name.replace('/', '.');
+    if(canonicalName.startsWith("java.")) {
+      Logger.trace("Skipping platform class: {}", canonicalName);
+      return null;
+    }
+
+    // Grab the class bytes.
+    final Map.Entry<byte[], Manifest> transformed = this.transformData(canonicalName, phase);
+    if(transformed == null) return null;
+
+    // Check if the class has already been loaded by the transform.
+    final Class<?> existingClass = this.findLoadedClass(canonicalName);
+    if(existingClass != null) {
+      Logger.trace("Skipping already defined transformed class: {}", canonicalName);
+      return existingClass;
+    }
+
+    // Find the package for this class.
+    final int classIndex = canonicalName.lastIndexOf('.');
+    if(classIndex > 0) {
+      final String packageName = canonicalName.substring(0, classIndex);
+      this.findPackage(packageName, transformed.getValue());
+    }
+
+    final byte[] bytes = transformed.getKey();
+    return this.defineClass(canonicalName, bytes, 0, bytes.length);
+  }
+
+  /* package */ Map.@Nullable Entry<byte@NotNull [], @NotNull Manifest> transformData(final @NotNull String name, final @NotNull TransformPhase phase) {
+    final String canonicalName = name.replace('/', '.');
+
+    final Map.Entry<byte[], Manifest> transformed = this.classData(canonicalName, phase);
+    if(transformed == null) return null;
+
+    // Prevent transforming classes that are excluded from transformation.
+    if(!this.transformationFilter.test(canonicalName)) {
+      Logger.trace("Skipping transformer excluded class: {}", canonicalName);
+      return null;
+    }
+
+    // Run the transformation.
+    final byte[] bytes = this.transformer.transform(canonicalName, transformed.getKey(), phase);
+    return new AbstractMap.SimpleEntry<>(bytes, transformed.getValue());
+  }
+
+  /* package */ Map.@Nullable Entry<byte@NotNull [], @NotNull Manifest> classData(final @NotNull String name, final @NotNull TransformPhase phase) {
+    final String internalName = name.replace('.', '/').concat(".class");
+
+    URL url = this.findResource(internalName);
+    if(url == null) {
+      if(phase == TransformPhase.INITIALIZE) return null;
+      url = this.parent.getResource(internalName);
+      if(url == null) return null;
+    }
+
+    try(final ResourceConnection connection = new ResourceConnection(url, this.manifestLocator)) {
+      final int length = connection.contentLength();
+      final InputStream stream = connection.stream();
+      final byte[] bytes = new byte[length];
+
+      // @formatter:off
+      int position = 0, remain = length, read;
+      while((read = stream.read(bytes, position, remain)) != -1 && remain > 0) {
+        position += read;
+        remain -= read;
+      }
+      // @formatter:on
+
+      final Manifest manifest = connection.manifest();
+      return new AbstractMap.SimpleEntry<>(bytes, manifest);
+    } catch(final Exception exception) {
+      Logger.trace(exception, "Failed to resolve class data: {}", internalName);
+      return null;
+    }
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="Packages">
+  /* package */ void findPackage(final @NotNull String name, final @Nullable Manifest manifest) {
+    final Package target = this.getPackage(name);
+    if(target == null) {
+      synchronized(this.lock) {
+        if(this.getPackage(name) != null) return;
+
+        final String path = name.replace('.', '/').concat("/");
+        // @formatter:off
+        String specTitle = null, specVersion = null, specVendor = null;
+        String implTitle = null, implVersion = null, implVendor = null;
+        // @formatter:on
+
+        if(manifest != null) {
+          final Attributes attributes = manifest.getAttributes(path);
+          if(attributes != null) {
+            specTitle = attributes.getValue(Attributes.Name.SPECIFICATION_TITLE);
+            specVersion = attributes.getValue(Attributes.Name.SPECIFICATION_VERSION);
+            specVendor = attributes.getValue(Attributes.Name.SPECIFICATION_VENDOR);
+            implTitle = attributes.getValue(Attributes.Name.IMPLEMENTATION_TITLE);
+            implVersion = attributes.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
+            implVendor = attributes.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);
+          }
+
+          final Attributes mainAttributes = manifest.getMainAttributes();
+          if(mainAttributes != null) {
+            if(specTitle == null) specTitle = mainAttributes.getValue(Attributes.Name.SPECIFICATION_TITLE);
+            if(specVersion == null) specVersion = mainAttributes.getValue(Attributes.Name.SPECIFICATION_VERSION);
+            if(specVendor == null) specVendor = mainAttributes.getValue(Attributes.Name.SPECIFICATION_VENDOR);
+            if(implTitle == null) implTitle = mainAttributes.getValue(Attributes.Name.IMPLEMENTATION_TITLE);
+            if(implVersion == null) implVersion = mainAttributes.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
+            if(implVendor == null) implVendor = mainAttributes.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);
+          }
+        }
+
+        this.definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, null);
+      }
+    }
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="Resources">
+  @Override
+  public @Nullable URL getResource(final @NotNull String name) {
+    requireNonNull(name, "name");
+
+    URL url = this.dynamic.getResource(name);
+    if(url == null) {
+      url = this.parent.getResource(name);
+    }
+
+    return url;
+  }
+
+  @Override
+  public @NotNull Enumeration<URL> getResources(final @NotNull String name) throws IOException {
+    requireNonNull(name, "name");
+
+    Enumeration<URL> resources = this.dynamic.getResources(name);
+    if(!resources.hasMoreElements()) {
+      resources = this.parent.getResources(name);
+    }
+
+    return resources;
+  }
+
+  @Override
+  protected @Nullable URL findResource(final @NotNull String name) {
+    return this.dynamic.findResource(name);
+  }
+
+  @Override
+  protected @NotNull Enumeration<URL> findResources(final @NotNull String name) throws IOException {
+    return this.dynamic.findResources(name);
+  }
+
+  @Override
+  public @Nullable InputStream getResourceAsStream(final @NotNull String name) {
+    requireNonNull(name, "name");
+
+    InputStream stream = this.dynamic.getResourceAsStream(name);
+    if(stream == null) {
+      stream = this.parent.getResourceAsStream(name);
+    }
+
+    return stream;
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="Manifest">
+  private @NotNull Optional<Manifest> locateManifest(final @NotNull URLConnection connection) {
+    try {
+      if(connection instanceof JarURLConnection) {
+        return Optional.ofNullable(((JarURLConnection) connection).getManifest());
+      }
+    } catch(final IOException exception) {
+      // Ignore
+    }
+
+    return Optional.empty();
+  }
+
+  private <I, O> @NotNull Function<I, O> alternate(final @Nullable Function<I, Optional<O>> first, final @Nullable Function<I, Optional<O>> second) {
+    if(second == null && first != null) return input -> first.apply(input).orElse(null);
+    if(first == null && second != null) return input -> second.apply(input).orElse(null);
+    if(first != null) return input -> first.apply(input).orElseGet(() -> second.apply(input).orElse(null));
+    return input -> null;
+  }
+  //</editor-fold>
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinBootstrap.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b30f702942473c6fdb7f20a7d869d4f9d1097f8
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinBootstrap.java
@@ -0,0 +1,33 @@
+package space.vectrix.ignite.launch.ember;
+
+import org.spongepowered.asm.service.IMixinServiceBootstrap;
+
+/**
+ * Provides the mixin bootstrap service for Ember.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class EmberMixinBootstrap implements IMixinServiceBootstrap {
+  /**
+   * Creates a new mixin bootstrap service.
+   *
+   * @since 1.0.0
+   */
+  public EmberMixinBootstrap() {
+  }
+
+  @Override
+  public String getName() {
+    return "Ember";
+  }
+
+  @Override
+  public String getServiceClassName() {
+    return "space.vectrix.ignite.launch.ember.EmberMixinService";
+  }
+
+  @Override
+  public void bootstrap() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinContainer.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..5492b2715313666afad16464b4345d748493bbeb
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinContainer.java
@@ -0,0 +1,76 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.nio.file.Path;
+import java.util.Map;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.asm.launch.platform.container.ContainerHandleURI;
+import org.spongepowered.asm.launch.platform.container.ContainerHandleVirtual;
+
+/**
+ * Represents the root container.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class EmberMixinContainer extends ContainerHandleVirtual {
+  /**
+   * Creates a new root container handle.
+   *
+   * @param name the name
+   * @since 1.0.0
+   */
+  public EmberMixinContainer(final @NotNull String name) {
+    super(name);
+  }
+
+  /**
+   * Adds a resource to this container.
+   *
+   * @param name the name
+   * @param path the path
+   * @since 1.0.0
+   */
+  public void addResource(final @NotNull String name, final @NotNull Path path) {
+    this.add(new ResourceContainer(name, path));
+  }
+
+  /**
+   * Adds a resource to this container.
+   *
+   * @param entry the entry
+   * @since 1.0.0
+   */
+  public void addResource(final Map.@NotNull Entry<String, Path> entry) {
+    this.add(new ResourceContainer(entry.getKey(), entry.getValue()));
+  }
+
+  @Override
+  public String toString() {
+    return "EmberMixinContainer{name=" + this.getName() + "}";
+  }
+
+  /* package */ static class ResourceContainer extends ContainerHandleURI {
+    private final String name;
+    private final Path path;
+
+    /* package */ ResourceContainer(final @NotNull String name, final @NotNull Path path) {
+      super(path.toUri());
+
+      this.name = name;
+      this.path = path;
+    }
+
+    public @NotNull String name() {
+      return this.name;
+    }
+
+    public @NotNull Path path() {
+      return this.path;
+    }
+
+    @Override
+    public @NotNull String toString() {
+      return "ResourceContainer{name=" + this.name + ", path=" + this.path + "}";
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinLogger.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..72590f0da58a4485ed1ae08524c78729dc2e4c8f
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinLogger.java
@@ -0,0 +1,115 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.asm.logging.ILogger;
+import org.spongepowered.asm.logging.Level;
+import org.spongepowered.asm.logging.LoggerAdapterAbstract;
+import org.tinylog.Logger;
+import org.tinylog.TaggedLogger;
+
+/* package */ final class EmberMixinLogger extends LoggerAdapterAbstract {
+  private static final Map<String, ILogger> LOGGERS = new ConcurrentHashMap<>();
+
+  /* package */ static @NotNull ILogger get(final @NotNull String name) {
+    return EmberMixinLogger.LOGGERS.computeIfAbsent(name, EmberMixinLogger::new);
+  }
+
+  private final TaggedLogger logger;
+
+  /* package */ EmberMixinLogger(final @NotNull String id) {
+    super(id);
+
+    this.logger = Logger.tag(id);
+  }
+
+  @Override
+  public String getType() {
+    return "TinyLogger (via Ignite)";
+  }
+
+  @Override
+  public void catching(final @NotNull Level level, final @NotNull Throwable throwable) {
+    switch(level) {
+      case WARN: {
+        this.logger.warn(throwable);
+        break;
+      }
+      case INFO: {
+        this.logger.info(throwable);
+        break;
+      }
+      case DEBUG: {
+        this.logger.debug(throwable);
+        break;
+      }
+      case TRACE: {
+        this.logger.trace(throwable);
+        break;
+      }
+      default: {
+        this.logger.error(throwable);
+        break;
+      }
+    }
+  }
+
+  @Override
+  public void log(final @NotNull Level level, final @NotNull String message, final @NotNull Object... args) {
+    switch(level) {
+      case WARN: {
+        this.logger.warn(message, args);
+        break;
+      }
+      case INFO: {
+        this.logger.info(message, args);
+        break;
+      }
+      case DEBUG: {
+        this.logger.debug(message, args);
+        break;
+      }
+      case TRACE: {
+        this.logger.trace(message, args);
+        break;
+      }
+      default: {
+        this.logger.error(message, args);
+        break;
+      }
+    }
+  }
+
+  @Override
+  public void log(final @NotNull Level level, final @NotNull String message, final @NotNull Throwable throwable) {
+    switch(level) {
+      case WARN: {
+        this.logger.warn(throwable, message);
+        break;
+      }
+      case INFO: {
+        this.logger.info(throwable, message);
+        break;
+      }
+      case DEBUG: {
+        this.logger.debug(throwable, message);
+        break;
+      }
+      case TRACE: {
+        this.logger.trace(throwable, message);
+        break;
+      }
+      default: {
+        this.logger.error(throwable, message);
+        break;
+      }
+    }
+  }
+
+  @Override
+  public <T extends Throwable> T throwing(final @NotNull T throwable) {
+    this.logger.error(throwable);
+    return throwable;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinService.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinService.java
new file mode 100644
index 0000000000000000000000000000000000000000..10cd247df9eb615e59ecf6c3cbf227e1c49cc426
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberMixinService.java
@@ -0,0 +1,244 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.jar.Manifest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.objectweb.asm.tree.ClassNode;
+import org.spongepowered.asm.launch.platform.container.IContainerHandle;
+import org.spongepowered.asm.logging.ILogger;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
+import org.spongepowered.asm.service.IClassBytecodeProvider;
+import org.spongepowered.asm.service.IClassProvider;
+import org.spongepowered.asm.service.IClassTracker;
+import org.spongepowered.asm.service.IMixinAuditTrail;
+import org.spongepowered.asm.service.IMixinInternal;
+import org.spongepowered.asm.service.IMixinService;
+import org.spongepowered.asm.service.ITransformer;
+import org.spongepowered.asm.service.ITransformerProvider;
+import org.spongepowered.asm.util.Constants;
+import org.spongepowered.asm.util.ReEntranceLock;
+import space.vectrix.ignite.launch.transformer.MixinTransformerImpl;
+
+/**
+ * Provides the mixin service for Ember.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class EmberMixinService implements IMixinService, IClassProvider, IClassBytecodeProvider, ITransformerProvider, IClassTracker {
+  private final ReEntranceLock lock;
+  private final EmberMixinContainer container;
+
+  /**
+   * Creates a new mixin service.
+   *
+   * @since 1.0.0
+   */
+  public EmberMixinService() {
+    this.lock = new ReEntranceLock(1);
+    this.container = new EmberMixinContainer("Ignite");
+  }
+
+  //<editor-fold desc="IMixinService">
+  @Override
+  public String getName() {
+    return "Ember/Ignite";
+  }
+
+  @Override
+  public boolean isValid() {
+    return true;
+  }
+
+  @Override
+  public void prepare() {
+  }
+
+  @Override
+  public MixinEnvironment.Phase getInitialPhase() {
+    return MixinEnvironment.Phase.PREINIT;
+  }
+
+  @Override
+  public void offer(final IMixinInternal internal) {
+    if(internal instanceof IMixinTransformerFactory) {
+      final MixinTransformerImpl transformer = Ember.instance().transformer().transformer(MixinTransformerImpl.class);
+      if(transformer == null) return;
+
+      transformer.offer((IMixinTransformerFactory) internal);
+    }
+  }
+
+  @Override
+  public void init() {
+  }
+
+  @Override
+  public void beginPhase() {
+  }
+
+  @Override
+  public void checkEnv(final @NotNull Object bootSource) {
+  }
+
+  @Override
+  public String getSideName() {
+    return Constants.SIDE_SERVER;
+  }
+
+  @Override
+  public ILogger getLogger(final @NotNull String name) {
+    return EmberMixinLogger.get(name);
+  }
+
+  @Override
+  public ReEntranceLock getReEntranceLock() {
+    return this.lock;
+  }
+
+  @Override
+  public IClassProvider getClassProvider() {
+    return this;
+  }
+
+  @Override
+  public IClassBytecodeProvider getBytecodeProvider() {
+    return this;
+  }
+
+  @Override
+  public ITransformerProvider getTransformerProvider() {
+    return this;
+  }
+
+  @Override
+  public IClassTracker getClassTracker() {
+    return this;
+  }
+
+  @Override
+  public IMixinAuditTrail getAuditTrail() {
+    return null;
+  }
+
+  @Override
+  public Collection<String> getPlatformAgents() {
+    return Collections.singletonList("org.spongepowered.asm.launch.platform.MixinPlatformAgentDefault");
+  }
+
+  @Override
+  public IContainerHandle getPrimaryContainer() {
+    return this.container;
+  }
+
+  @Override
+  public Collection<IContainerHandle> getMixinContainers() {
+    return Collections.emptyList();
+  }
+
+  @Override
+  public InputStream getResourceAsStream(final @NotNull String name) {
+    final EmberClassLoader loader = Ember.instance().loader();
+    return loader.getResourceAsStream(name);
+  }
+
+  @Override
+  public MixinEnvironment.CompatibilityLevel getMinCompatibilityLevel() {
+    return MixinEnvironment.CompatibilityLevel.JAVA_8;
+  }
+
+  @Override
+  public MixinEnvironment.CompatibilityLevel getMaxCompatibilityLevel() {
+    return MixinEnvironment.CompatibilityLevel.JAVA_17;
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="IClassProvider">
+  @Override
+  public @NotNull URL[] getClassPath() {
+    return new URL[0];
+  }
+
+  @Override
+  public @NotNull Class<?> findClass(final @NotNull String name) throws ClassNotFoundException {
+    return Class.forName(name, true, Ember.instance().loader());
+  }
+
+  @Override
+  public @NotNull Class<?> findClass(final @NotNull String name, final boolean initialize) throws ClassNotFoundException {
+    return Class.forName(name, initialize, Ember.instance().loader());
+  }
+
+  @Override
+  public @NotNull Class<?> findAgentClass(final @NotNull String name, final boolean initialize) throws ClassNotFoundException {
+    return Class.forName(name, initialize, Ember.class.getClassLoader());
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="IClassBytecodeProvider">
+  @Override
+  public @NotNull ClassNode getClassNode(final @NotNull String name) throws ClassNotFoundException, IOException {
+    return this.getClassNode(name, true);
+  }
+
+  @Override
+  public @NotNull ClassNode getClassNode(final @NotNull String name, final boolean runTransformers) throws ClassNotFoundException, IOException {
+    if(!runTransformers) throw new IllegalStateException("ClassNodes must always be provided transformed!");
+
+    final Ember ember = Ember.instance();
+    final EmberClassLoader loader = ember.loader();
+    final EmberTransformer transformer = ember.transformer();
+
+    final MixinTransformerImpl mixinTransformer = transformer.transformer(MixinTransformerImpl.class);
+    if(mixinTransformer == null) throw new ClassNotFoundException("Mixin transformer is not available!");
+
+    final String canonicalName = name.replace('/', '.');
+    final String internalName = name.replace('.', '/');
+
+    final @Nullable Map.Entry<byte[], Manifest> entry = loader.classData(canonicalName, TransformPhase.MIXIN);
+    if(entry == null) throw new ClassNotFoundException(canonicalName);
+
+    return mixinTransformer.classNode(canonicalName, internalName, entry.getKey());
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="ITransformerProvider">
+  @Override
+  public Collection<ITransformer> getTransformers() {
+    return Collections.emptyList();
+  }
+
+  @Override
+  public Collection<ITransformer> getDelegatedTransformers() {
+    return Collections.emptyList();
+  }
+
+  @Override
+  public void addTransformerExclusion(final @NotNull String name) {
+  }
+  //</editor-fold>
+
+  //<editor-fold desc="IClassTracker">
+  @Override
+  public void registerInvalidClass(final @NotNull String name) {
+  }
+
+  @Override
+  public boolean isClassLoaded(final @NotNull String name) {
+    final EmberClassLoader loader = Ember.instance().loader();
+    return loader.hasClass(name);
+  }
+
+  @Override
+  public String getClassRestrictions(final @NotNull String name) {
+    return "";
+  }
+  //</editor-fold>
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/EmberTransformer.java b/src/main/java/space/vectrix/ignite/launch/ember/EmberTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..89a75873306e0c69b5d30a4880abb92b8cec259b
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/EmberTransformer.java
@@ -0,0 +1,127 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.ClassNode;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.tinylog.Logger;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Represents the transformer.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class EmberTransformer {
+  private final ServiceLoader<TransformerService> serviceLoader = ServiceLoader.load(TransformerService.class, Ember.class.getClassLoader());
+  private final Map<Class<? extends TransformerService>, TransformerService> transformers = new IdentityHashMap<>();
+
+  private Predicate<String> exclusionFilter = path -> false;
+
+  /* package */ EmberTransformer() {
+    for(final TransformerService service : this.serviceLoader) {
+      this.transformers.put(service.getClass(), service);
+    }
+  }
+
+  /**
+   * Adds a new exclusion filter.
+   *
+   * <p>If the predicate results to {@code true}, transformation will not be
+   * applied.</p>
+   *
+   * @param predicate the filter
+   * @since 1.0.0
+   */
+  public void exclude(final @NotNull Predicate<String> predicate) {
+    this.exclusionFilter = this.exclusionFilter.or(predicate);
+  }
+
+  /**
+   * Returns the transformer for the given class.
+   *
+   * @param transformer the transformer class
+   * @param <T> the transformer type
+   * @return the transformer, if present
+   * @since 1.0.0
+   */
+  public <T extends TransformerService> @Nullable T transformer(final @NotNull Class<T> transformer) {
+    return transformer.cast(this.transformers.get(transformer));
+  }
+
+  /**
+   * Returns an unmodifiable collection of transformers.
+   *
+   * @return the transformers
+   * @since 1.0.0
+   */
+  public @NotNull Collection<TransformerService> transformers() {
+    return Collections.unmodifiableCollection(this.transformers.values());
+  }
+
+  /* package */ byte@NotNull [] transform(final @NotNull String className, final byte@NotNull [] input, final @NotNull TransformPhase phase) {
+    final String internalName = className.replace('.', '/');
+
+    // Check if the path is excluded from transformation.
+    if(this.exclusionFilter.test(internalName)) {
+      return input;
+    }
+
+    final Type type = Type.getObjectType(internalName);
+    final ClassNode node = new ClassNode(IgniteConstants.ASM_VERSION);
+    if(input.length > 0) {
+      final ClassReader reader = new ClassReader(input);
+      reader.accept(node, 0);
+    } else {
+      node.name = type.getInternalName();
+      node.version = MixinEnvironment.getCompatibilityLevel().getClassVersion();
+      node.superName = "java/lang/Object";
+    }
+
+    final List<TransformerService> transformers = this.order(phase);
+    boolean transformed = false;
+    {
+      for(final TransformerService service : transformers) {
+        try {
+          // If the transformer should not transform the class, skip it.
+          if(!service.shouldTransform(type, node)) continue;
+          // Attempt to transform the class.
+          transformed |= service.transform(type, node, phase);
+        } catch(final Throwable throwable) {
+          Logger.error(throwable, "Failed to transform {} with {}", type.getClassName(), service.getClass().getName());
+        }
+      }
+    }
+
+    // If no transformations were applied, return the original input.
+    if(!transformed) return input;
+
+    final ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+    node.accept(writer);
+
+    return writer.toByteArray();
+  }
+
+  private List<TransformerService> order(final @NotNull TransformPhase phase) {
+    return this.transformers.values().stream()
+      .filter(value -> value.priority(phase) != -1) // Filter out transformers that do not apply to the given phase.
+      .sorted((first, second) -> {
+        final int firstPriority = first.priority(phase);
+        final int secondPriority = second.priority(phase);
+        return Integer.compare(firstPriority, secondPriority);
+      })
+      .collect(Collectors.toList());
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/LaunchService.java b/src/main/java/space/vectrix/ignite/launch/ember/LaunchService.java
new file mode 100644
index 0000000000000000000000000000000000000000..0872f175794324d77378d72aeaf940616247d231
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/LaunchService.java
@@ -0,0 +1,48 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.util.concurrent.Callable;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents the launch service for Ember.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public interface LaunchService {
+  /**
+   * Executed at the very beginning of the launch process, before mixin has
+   * been initialized.
+   *
+   * @since 1.0.0
+   */
+  void initialize();
+
+  /**
+   * Configures the class loader, before mixin has been initialized.
+   *
+   * @param classLoader the class loader
+   * @param transformer the transformer
+   * @since 1.0.0
+   */
+  void configure(final @NotNull EmberClassLoader classLoader, final @NotNull EmberTransformer transformer);
+
+  /**
+   * Executed after mixin has been initialized, but before the game has
+   * launched.
+   *
+   * @param transformer the transformer
+   * @since 1.0.0
+   */
+  void prepare(final @NotNull EmberTransformer transformer);
+
+  /**
+   * Launches the game.
+   *
+   * @param arguments the launch arguments
+   * @param loader the class loader
+   * @return a callable
+   * @since 1.0.0
+   */
+  @NotNull Callable<Void> launch(final @NotNull String@NotNull [] arguments, final @NotNull EmberClassLoader loader);
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/ResourceConnection.java b/src/main/java/space/vectrix/ignite/launch/ember/ResourceConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fee80d2c6f6cb47d26023ac0aa8be54bf7a3869
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/ResourceConnection.java
@@ -0,0 +1,38 @@
+package space.vectrix.ignite.launch.ember;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.function.Function;
+import java.util.jar.Manifest;
+import org.jetbrains.annotations.NotNull;
+
+/* package */ final class ResourceConnection implements AutoCloseable {
+  private final URLConnection connection;
+  private final InputStream stream;
+  private final Function<URLConnection, Manifest> manifestFunction;
+
+  /* package */ ResourceConnection(final @NotNull URL url, final @NotNull Function<URLConnection, Manifest> manifestLocator) throws IOException {
+    this.connection = url.openConnection();
+    this.stream = this.connection.getInputStream();
+    this.manifestFunction = manifestLocator;
+  }
+
+  /* package */ int contentLength() {
+    return this.connection.getContentLength();
+  }
+
+  /* package */ @NotNull InputStream stream() {
+    return this.stream;
+  }
+
+  /* package */ @NotNull Manifest manifest() {
+    return this.manifestFunction.apply(this.connection);
+  }
+
+  @Override
+  public void close() throws Exception {
+    this.stream.close();
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/TransformPhase.java b/src/main/java/space/vectrix/ignite/launch/ember/TransformPhase.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c67e955e7aeb0ed2b6b4f718ade31a3d768eef4
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/TransformPhase.java
@@ -0,0 +1,23 @@
+package space.vectrix.ignite.launch.ember;
+
+/**
+ * Represents the phase of a transformation.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public enum TransformPhase {
+  /**
+   * The transformation phase that is used when the class is loaded.
+   *
+   * @since 1.0.0
+   */
+  INITIALIZE,
+
+  /**
+   * The transformation phase that is used when mixin is being applied.
+   *
+   * @since 1.0.0
+   */
+  MIXIN
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/TransformerService.java b/src/main/java/space/vectrix/ignite/launch/ember/TransformerService.java
new file mode 100644
index 0000000000000000000000000000000000000000..adfced55671e7cfae0a77484b3a9f13fec0df062
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/TransformerService.java
@@ -0,0 +1,60 @@
+package space.vectrix.ignite.launch.ember;
+
+import org.jetbrains.annotations.NotNull;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.ClassNode;
+
+/**
+ * Represents a transformer service for Ember.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public interface TransformerService {
+  /**
+   * Executed after mixin has completed bootstrapping, but before the game has
+   * launched.
+   *
+   * @since 1.0.0
+   */
+  void prepare();
+
+  /**
+   * Returns the priority of this transformer for the given {@link TransformPhase}.
+   *
+   * <p>A result of -1 means this transformer should not be applied during
+   * the given phase.</p>
+   *
+   * <p>This method will be called multiple times for sorting the transformers
+   * each class.</p>
+   *
+   * @param phase the transform phase
+   * @return the priority
+   * @since 1.0.0
+   */
+  int priority(final @NotNull TransformPhase phase);
+
+  /**
+   * Returns {@code true} if this transformer should transform the given
+   * {@link Type} and {@link ClassNode}, otherwise returns {@code false}.
+   *
+   * @param type the type
+   * @param node the class node
+   * @return whether the class should be transformed
+   * @since 1.0.0
+   */
+  boolean shouldTransform(final @NotNull Type type, final @NotNull ClassNode node);
+
+  /**
+   * Attempts to transform a class, with the given {@link Type}, {@link ClassNode}
+   * and {@link TransformPhase} and returns {@code true} if modifications were
+   * made, otherwise returns {@code false}.
+   *
+   * @param type the type
+   * @param node the class node
+   * @param phase the transform phase
+   * @return whether the class was transformed
+   * @since 1.0.0
+   */
+  boolean transform(final @NotNull Type type, final @NotNull ClassNode node, final @NotNull TransformPhase phase) throws Throwable;
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/ember/package-info.java b/src/main/java/space/vectrix/ignite/launch/ember/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd85b7b0df72b4ed68edfd3c34f4d1904e024eb6
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/ember/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * Ember: The launch transformation system.
+ */
+package space.vectrix.ignite.launch.ember;
diff --git a/src/main/java/space/vectrix/ignite/launch/package-info.java b/src/main/java/space/vectrix/ignite/launch/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b99bed16d85957c3ab53d34d1f9ec6d8b306afb
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the launch handlers.
+ */
+package space.vectrix.ignite.launch;
diff --git a/src/main/java/space/vectrix/ignite/launch/transformer/AccessTransformerImpl.java b/src/main/java/space/vectrix/ignite/launch/transformer/AccessTransformerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5fa296dc211bd7ec4bc74fccb1247e6bab2ab00
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/transformer/AccessTransformerImpl.java
@@ -0,0 +1,84 @@
+package space.vectrix.ignite.launch.transformer;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import net.fabricmc.accesswidener.AccessWidener;
+import net.fabricmc.accesswidener.AccessWidenerClassVisitor;
+import net.fabricmc.accesswidener.AccessWidenerReader;
+import org.jetbrains.annotations.NotNull;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.ClassNode;
+import space.vectrix.ignite.launch.ember.TransformPhase;
+import space.vectrix.ignite.launch.ember.TransformerService;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Provides the access transformer for Ignite.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class AccessTransformerImpl implements TransformerService {
+  private final AccessWidener widener = new AccessWidener();
+  private final AccessWidenerReader widenerReader = new AccessWidenerReader(this.widener);
+
+  /**
+   * Adds a widener to this transformer.
+   *
+   * @param path the configuration path
+   * @throws IOException if an error occurs while reading the widener
+   * @since 1.0.0
+   */
+  public void addWidener(final @NotNull Path path) throws IOException {
+    try(final BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
+      this.widenerReader.read(reader);
+    }
+  }
+
+  @Override
+  public void prepare() {
+  }
+
+  @Override
+  public int priority(final @NotNull TransformPhase phase) {
+    // Only transform targets on the initialize phase.
+    if(phase != TransformPhase.INITIALIZE) return -1;
+    // This prioritizes access widener near the beginning of the transformation
+    // pipeline.
+    return 25;
+  }
+
+  @Override
+  public boolean shouldTransform(final @NotNull Type type, final @NotNull ClassNode node) {
+    // Only transform targets that need to be widened.
+    return this.widener.getTargets().contains(node.name.replace('/', '.'));
+  }
+
+  @Override
+  public boolean transform(final @NotNull Type type, final @NotNull ClassNode node, final @NotNull TransformPhase phase) throws Throwable {
+    final ClassNode widened = new ClassNode(IgniteConstants.ASM_VERSION);
+    widened.accept(node);
+
+    final ClassVisitor visitor = AccessWidenerClassVisitor.createClassVisitor(IgniteConstants.ASM_VERSION, node, this.widener);
+
+    node.visibleAnnotations = null;
+    node.invisibleAnnotations = null;
+    node.visibleTypeAnnotations = null;
+    node.invisibleTypeAnnotations = null;
+    node.attrs = null;
+    node.nestMembers = null;
+    node.permittedSubclasses = null;
+    node.recordComponents = null;
+    node.innerClasses.clear();
+    node.fields.clear();
+    node.methods.clear();
+    node.interfaces.clear();
+
+    widened.accept(visitor);
+    return true;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/transformer/MixinTransformerImpl.java b/src/main/java/space/vectrix/ignite/launch/transformer/MixinTransformerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e7fdb22fe887ec3832203631d1e6b98da3a5944
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/transformer/MixinTransformerImpl.java
@@ -0,0 +1,106 @@
+package space.vectrix.ignite.launch.transformer;
+
+import org.jetbrains.annotations.NotNull;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.ClassNode;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
+import org.spongepowered.asm.service.ISyntheticClassRegistry;
+import org.spongepowered.asm.transformers.MixinClassReader;
+import space.vectrix.ignite.launch.ember.TransformPhase;
+import space.vectrix.ignite.launch.ember.TransformerService;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Provides the mixin transformer for Ignite.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class MixinTransformerImpl implements TransformerService {
+  private IMixinTransformerFactory transformerFactory;
+  private IMixinTransformer transformer;
+  private ISyntheticClassRegistry registry;
+
+  /**
+   * Offers the transformer factory to this transformer.
+   *
+   * @param factory the transformer factory
+   * @since 1.0.0
+   */
+  public void offer(final @NotNull IMixinTransformerFactory factory) {
+    this.transformerFactory = factory;
+  }
+
+  @Override
+  public void prepare() {
+    if(this.transformerFactory == null) throw new IllegalStateException("Transformer factory is not available!");
+    this.transformer = this.transformerFactory.createTransformer();
+    this.registry = this.transformer.getExtensions().getSyntheticClassRegistry();
+  }
+
+  @Override
+  public int priority(final @NotNull TransformPhase phase) {
+    // We don't want mixin trying to transform targets it's already
+    // transforming.
+    if(phase == TransformPhase.MIXIN) return -1;
+    // This prioritizes mixin in the middle of the transformation
+    // pipeline.
+    return 50;
+  }
+
+  @Override
+  public boolean shouldTransform(final @NotNull Type type, final @NotNull ClassNode node) {
+    // We want to send everything for mixin to decide.
+    return true;
+  }
+
+  @Override
+  public boolean transform(final @NotNull Type type, final @NotNull ClassNode node, final @NotNull TransformPhase phase) throws Throwable {
+    // Generate the class if it is synthetic through mixin.
+    if(this.shouldGenerateClass(type)) {
+      return this.generateClass(type, node);
+    }
+
+    // Transform the class through mixin.
+    return this.transformer.transformClass(MixinEnvironment.getCurrentEnvironment(), type.getClassName(), node);
+  }
+
+  /**
+   * Returns the class node for the given canonical name, internal name and
+   * input class bytes.
+   *
+   * @param canonicalName the canonical name
+   * @param internalName the internal name
+   * @param input the input class bytes
+   * @return the class node
+   * @throws ClassNotFoundException if the class could not be found
+   * @since 1.0.0
+   */
+  public @NotNull ClassNode classNode(final @NotNull String canonicalName, final @NotNull String internalName, final byte@NotNull [] input) throws ClassNotFoundException {
+    if(input.length != 0) {
+      final ClassNode node = new ClassNode(IgniteConstants.ASM_VERSION);
+      final ClassReader reader = new MixinClassReader(input, canonicalName);
+      reader.accept(node, 0);
+      return node;
+    }
+
+    final Type type = Type.getObjectType(internalName);
+    if(this.shouldGenerateClass(type)) {
+      final ClassNode node = new ClassNode(IgniteConstants.ASM_VERSION);
+      if(this.generateClass(type, node)) return node;
+    }
+
+    throw new ClassNotFoundException(canonicalName);
+  }
+
+  /* package */ boolean shouldGenerateClass(final @NotNull Type type) {
+    return this.registry.findSyntheticClass(type.getClassName()) != null;
+  }
+
+  /* package */ boolean generateClass(final @NotNull Type type, final @NotNull ClassNode node) {
+    return this.transformer.generateClass(MixinEnvironment.getCurrentEnvironment(), type.getClassName(), node);
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/launch/transformer/package-info.java b/src/main/java/space/vectrix/ignite/launch/transformer/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfb19e5719db5b4ce05e9429472b00dfdca6a2ab
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/launch/transformer/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the transformers for Ignite.
+ */
+package space.vectrix.ignite.launch.transformer;
diff --git a/src/main/java/space/vectrix/ignite/mod/ModConfig.java b/src/main/java/space/vectrix/ignite/mod/ModConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..0dd21e3738108ce4f0d7399560a2be6976d63117
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModConfig.java
@@ -0,0 +1,125 @@
+package space.vectrix.ignite.mod;
+
+import com.google.gson.annotations.SerializedName;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents a mod config.
+ *
+ * @since 1.0.0
+ */
+public final class ModConfig {
+  private @SerializedName("id") String id;
+  private @SerializedName("version") String version;
+  private @SerializedName("mixins") List<String> mixins;
+  private @SerializedName("wideners") List<String> wideners;
+
+  /**
+   * Creates a new mod config.
+   *
+   * @since 1.0.0
+   */
+  public ModConfig() {
+  }
+
+  /**
+   * Creates a new mod config.
+   *
+   * @param id the id
+   * @param version the version
+   * @since 1.0.0
+   */
+  public ModConfig(final @NotNull String id,
+                   final @NotNull String version) {
+    this.id = id;
+    this.version = version;
+  }
+
+  /**
+   * Creates a new mod config.
+   *
+   * @param id the id
+   * @param version the version
+   * @param mixins the mixins
+   * @param wideners the wideners
+   * @since 1.0.0
+   */
+  public ModConfig(final @NotNull String id,
+                   final @NotNull String version,
+                   final @NotNull List<String> mixins,
+                   final @NotNull List<String> wideners) {
+    this.id = id;
+    this.version = version;
+    this.mixins = mixins;
+    this.wideners = wideners;
+  }
+
+  /**
+   * Returns the mod id.
+   *
+   * @return the id
+   * @since 1.0.0
+   */
+  public @NotNull String id() {
+    return this.id;
+  }
+
+  /**
+   * Returns the mod version.
+   *
+   * @return the version
+   * @since 1.0.0
+   */
+  public @NotNull String version() {
+    return this.version;
+  }
+
+  /**
+   * Returns the list of mod mixins.
+   *
+   * @return the mod mixins
+   * @since 1.0.0
+   */
+  public @Nullable List<String> mixins() {
+    return this.mixins;
+  }
+
+  /**
+   * Returns the list of mod wideners.
+   *
+   * @return the mod wideners
+   * @since 1.0.0
+   */
+  public @Nullable List<String> wideners() {
+    return this.wideners;
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(this.id, this.version, this.mixins);
+  }
+
+  @Override
+  public boolean equals(final @Nullable Object other) {
+    if(this == other) return true;
+    if(!(other instanceof ModConfig)) return false;
+    final ModConfig that = (ModConfig) other;
+    return Objects.equals(this.id, that.id)
+      && Objects.equals(this.version, that.version)
+      && Objects.equals(this.mixins, that.mixins)
+      && Objects.equals(this.wideners, that.wideners);
+  }
+
+  @Override
+  public String toString() {
+    return "ModConfig(" +
+      "id=" + this.id + ", " +
+      "version=" + this.version + ", " +
+      "mixins=" + Arrays.toString(this.mixins.toArray(new String[0])) + ", " +
+      "wideners=" + Arrays.toString(this.wideners.toArray(new String[0])) + ")";
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModContainer.java b/src/main/java/space/vectrix/ignite/mod/ModContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f9dc01ba1efc47a3f04bd330850701ff5cc2b30
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModContainer.java
@@ -0,0 +1,46 @@
+package space.vectrix.ignite.mod;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.TaggedLogger;
+
+/**
+ * Represents a mod container.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+@ApiStatus.NonExtendable
+public interface ModContainer {
+  /**
+   * Returns a {@link TaggedLogger} for this mod.
+   *
+   * @return the mod logger
+   * @since 1.0.0
+   */
+  @NotNull TaggedLogger logger();
+
+  /**
+   * Returns the mod id.
+   *
+   * @return the id
+   * @since 1.0.0
+   */
+  @NotNull String id();
+
+  /**
+   * Returns the mod version.
+   *
+   * @return the version
+   * @since 1.0.0
+   */
+  @NotNull String version();
+
+  /**
+   * Returns the mod resource.
+   *
+   * @return the resource
+   * @since 1.0.0
+   */
+  @NotNull ModResource resource();
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModContainerImpl.java b/src/main/java/space/vectrix/ignite/mod/ModContainerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..517530483698ea33098b195f24c3b56c92f54b4c
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModContainerImpl.java
@@ -0,0 +1,75 @@
+package space.vectrix.ignite.mod;
+
+import java.util.Objects;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.tinylog.TaggedLogger;
+
+/**
+ * Represents a mod container.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class ModContainerImpl implements ModContainer {
+  private final TaggedLogger logger;
+  private final ModResource resource;
+  private final ModConfig config;
+
+  /* package */ ModContainerImpl(final @NotNull TaggedLogger logger,
+                                 final @NotNull ModResource resource,
+                                 final @NotNull ModConfig config) {
+    this.logger = logger;
+    this.resource = resource;
+    this.config = config;
+  }
+
+  @Override
+  public @NotNull TaggedLogger logger() {
+    return this.logger;
+  }
+
+  @Override
+  public @NotNull String id() {
+    return this.config.id();
+  }
+
+  @Override
+  public @NotNull String version() {
+    return this.config.version();
+  }
+
+  @Override
+  public @NotNull ModResource resource() {
+    return this.resource;
+  }
+
+  /**
+   * Returns the mod config.
+   *
+   * @return the config
+   * @since 1.0.0
+   */
+  public @NotNull ModConfig config() {
+    return this.config;
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(this.resource, this.config);
+  }
+
+  @Override
+  public boolean equals(final @Nullable Object other) {
+    if(this == other) return true;
+    if(!(other instanceof ModContainerImpl)) return false;
+    final ModContainerImpl that = (ModContainerImpl) other;
+    return Objects.equals(this.resource, that.resource)
+      && Objects.equals(this.config, that.config);
+  }
+
+  @Override
+  public String toString() {
+    return "ModContainerImpl(id=" + this.id() + ", version=" + this.version() + ", resource=" + this.resource() + ", config=" + this.config() + ")";
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModResource.java b/src/main/java/space/vectrix/ignite/mod/ModResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..546039749d8d48c63de66e8c8a6a6db7bc30ed20
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModResource.java
@@ -0,0 +1,49 @@
+package space.vectrix.ignite.mod;
+
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.util.jar.Manifest;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.UnknownNullability;
+
+/**
+ * Represents a mod resource.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+@ApiStatus.NonExtendable
+public interface ModResource {
+  /**
+   * Returns the resource locator type.
+   *
+   * @return the resource locator type
+   * @since 1.0.0
+   */
+  @NotNull String locator();
+
+  /**
+   * Returns the resource path.
+   *
+   * @return the resource path
+   * @since 1.0.0
+   */
+  @NotNull Path path();
+
+  /**
+   * Returns the {@link Manifest} for this resource.
+   *
+   * @return the manifest
+   * @since 1.0.0
+   */
+  @UnknownNullability Manifest manifest();
+
+  /**
+   * Returns the {@link FileSystem} for this resource.
+   *
+   * @return the file system
+   * @since 1.0.0
+   */
+  @NotNull FileSystem fileSystem();
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModResourceImpl.java b/src/main/java/space/vectrix/ignite/mod/ModResourceImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8f1d419addeb6ba0126406e0926405da157868c
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModResourceImpl.java
@@ -0,0 +1,81 @@
+package space.vectrix.ignite.mod;
+
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Path;
+import java.util.Objects;
+import java.util.jar.Manifest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.UnknownNullability;
+
+/**
+ * Represents a mod resource that may not be resolved.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class ModResourceImpl implements ModResource {
+  private final String locator;
+  private final Path path;
+  private final Manifest manifest;
+
+  private FileSystem fileSystem;
+
+  /* package */ ModResourceImpl(final @NotNull String locator,
+                                final @NotNull Path path,
+                                final @UnknownNullability Manifest manifest) {
+    this.locator = locator;
+    this.path = path;
+    this.manifest = manifest;
+  }
+
+  @Override
+  public @NotNull String locator() {
+    return this.locator;
+  }
+
+  @Override
+  public @NotNull Path path() {
+    return this.path;
+  }
+
+  @Override
+  public @UnknownNullability Manifest manifest() {
+    return this.manifest;
+  }
+
+  @Override
+  public @NotNull FileSystem fileSystem() {
+    if(this.fileSystem == null) {
+      try {
+        this.fileSystem = FileSystems.newFileSystem(this.path(), this.getClass().getClassLoader());
+      } catch(final IOException exception) {
+        throw new RuntimeException(exception);
+      }
+    }
+
+    return this.fileSystem;
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(this.locator, this.path, this.manifest);
+  }
+
+  @Override
+  public boolean equals(final @Nullable Object other) {
+    if(this == other) return true;
+    if(!(other instanceof ModResourceImpl)) return false;
+    final ModResourceImpl that = (ModResourceImpl) other;
+    return Objects.equals(this.locator, that.locator)
+      && Objects.equals(this.path, that.path)
+      && Objects.equals(this.manifest, that.manifest);
+  }
+
+  @Override
+  public String toString() {
+    return "ModResourceImpl{locator='" + this.locator + ", path=" + this.path + ", manifest=" + this.manifest + "}";
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModResourceLoader.java b/src/main/java/space/vectrix/ignite/mod/ModResourceLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..9bc2d74805659fab6a4a0fcab001880ecab1916f
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModResourceLoader.java
@@ -0,0 +1,52 @@
+package space.vectrix.ignite.mod;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Represents the mod resource loader.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class ModResourceLoader {
+  /* package */ @NotNull List<ModContainerImpl> loadResources(final @NotNull ModsImpl engine) {
+    final List<ModContainerImpl> containers = new ArrayList<>();
+
+    for(final ModResource resource : engine.resources()) {
+      if(resource.locator().equals(ModResourceLocator.LAUNCHER_LOCATOR) || resource.locator().equals(ModResourceLocator.GAME_LOCATOR)) {
+        final ModConfig config = new ModConfig(
+          IgniteConstants.API_TITLE,
+          IgniteConstants.API_VERSION
+        );
+
+        containers.add(new ModContainerImpl(Logger.tag(config.id()), resource, config));
+        continue;
+      }
+
+      final Path resourcePath = resource.path();
+      try(final JarFile jarFile = new JarFile(resourcePath.toFile())) {
+        final JarEntry jarEntry = jarFile.getJarEntry(IgniteConstants.MOD_CONFIG);
+        if(jarEntry == null) continue;
+
+        final InputStream inputStream = jarFile.getInputStream(jarEntry);
+        final ModConfig config = IgniteConstants.GSON.fromJson(new InputStreamReader(inputStream), ModConfig.class);
+
+        containers.add(new ModContainerImpl(Logger.tag(config.id()), resource, config));
+      } catch(final IOException exception) {
+        // Ignore
+      }
+    }
+
+    return containers;
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModResourceLocator.java b/src/main/java/space/vectrix/ignite/mod/ModResourceLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..e440965e708696ec1e2fd3ae3552a36b0cdec364
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModResourceLocator.java
@@ -0,0 +1,93 @@
+package space.vectrix.ignite.mod;
+
+import java.io.File;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.stream.Collectors;
+import org.jetbrains.annotations.NotNull;
+import space.vectrix.ignite.Blackboard;
+import space.vectrix.ignite.IgniteBootstrap;
+import space.vectrix.ignite.util.IgniteConstants;
+
+/**
+ * Represents the mod resource locator.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class ModResourceLocator {
+  public static final String JAVA_LOCATOR = "java_locator";
+  public static final String LAUNCHER_LOCATOR = "launcher_locator";
+  public static final String GAME_LOCATOR = "game_locator";
+
+  /* package */ @NotNull List<ModResourceImpl> locateResources() {
+    final List<ModResourceImpl> resources = new ArrayList<>();
+
+    // Add the launcher and game resources.
+    resources.add(this.createLauncherResource());
+    resources.add(this.createGameResource());
+
+    // Retrieve the mods from the mods directory.
+    final Path modDirectory = Blackboard.raw(Blackboard.MODS_DIRECTORY);
+    try {
+      if(modDirectory == null) {
+        throw new RuntimeException("Failed to get mods directory!");
+      }
+
+      if(Files.notExists(modDirectory)) {
+        //noinspection ResultOfMethodCallIgnored
+        modDirectory.toFile().mkdirs();
+      }
+
+      //noinspection resource
+      for(final Path childDirectory : Files.walk(modDirectory).collect(Collectors.toList())) {
+        if(!Files.isRegularFile(childDirectory) || !childDirectory.getFileName().toString().endsWith(".jar")) {
+          continue;
+        }
+        
+          if (childDirectory.toFile().isDirectory()) continue;
+          if (!childDirectory.getParent().toFile().getName().equalsIgnoreCase("plugins")) continue;
+
+        try(final JarFile jarFile = new JarFile(childDirectory.toFile())) {
+          final JarEntry jarEntry = jarFile.getJarEntry(IgniteConstants.MOD_CONFIG);
+          if(jarEntry == null) continue;
+
+          resources.add(new ModResourceImpl(ModResourceLocator.JAVA_LOCATOR, childDirectory, jarFile.getManifest()));
+        }
+      }
+    } catch(final Throwable throwable) {
+      throw new RuntimeException("Failed to walk the mods directory!", throwable);
+    }
+
+    return resources;
+  }
+
+  private @NotNull ModResourceImpl createLauncherResource() {
+    final File launcherFile;
+    try {
+      launcherFile = new File(IgniteBootstrap.class.getProtectionDomain().getCodeSource().getLocation().toURI());
+    } catch(final URISyntaxException exception) {
+      throw new RuntimeException("Failed to get launcher path!", exception);
+    }
+
+    try(final JarFile jarFile = new JarFile(launcherFile)) {
+      return new ModResourceImpl(ModResourceLocator.LAUNCHER_LOCATOR, launcherFile.toPath(), jarFile.getManifest());
+    } catch(final Exception exception) {
+      throw new RuntimeException("Failed to get launcher manifest!", exception);
+    }
+  }
+
+  private @NotNull ModResourceImpl createGameResource() {
+    final File gameFile = Blackboard.raw(Blackboard.GAME_JAR).toFile();
+    try(final JarFile jarFile = new JarFile(gameFile)) {
+      return new ModResourceImpl(ModResourceLocator.GAME_LOCATOR, gameFile.toPath(), jarFile.getManifest());
+    } catch(final Exception exception) {
+      throw new RuntimeException("Failed to get game manifest!", exception);
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/Mods.java b/src/main/java/space/vectrix/ignite/mod/Mods.java
new file mode 100644
index 0000000000000000000000000000000000000000..be3eda16e055663f879d6fa45d81db08c0376fc7
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/Mods.java
@@ -0,0 +1,51 @@
+package space.vectrix.ignite.mod;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents the mod manager.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+@ApiStatus.NonExtendable
+public interface Mods {
+  /**
+   * Returns {@code true} if the given mod is loaded, otherwise it returns
+   * {@code false}.
+   *
+   * @param id the mod identifier
+   * @return whether the mod is loaded
+   * @since 1.0.0
+   */
+  boolean loaded(final @NotNull String id);
+
+  /**
+   * Returns the {@link ModContainer} for the given mod identifier.
+   *
+   * @param id the mod identifier
+   * @return the mod container
+   * @since 1.0.0
+   */
+  @NotNull Optional<ModContainer> container(final @NotNull String id);
+
+  /**
+   * Returns a list of the located mod resources.
+   *
+   * @return the located mod resources
+   * @since 1.0.0
+   */
+  @NotNull List<ModResource> resources();
+
+  /**
+   * Returns a collection of the resolved mod containers.
+   *
+   * @return the resolved mod containers
+   * @since 1.0.0
+   */
+  @NotNull Collection<ModContainer> containers();
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/ModsImpl.java b/src/main/java/space/vectrix/ignite/mod/ModsImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..2671333b773ded17ae887d945d2c3fcd599eaabe
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/ModsImpl.java
@@ -0,0 +1,155 @@
+package space.vectrix.ignite.mod;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.asm.mixin.Mixins;
+import org.spongepowered.asm.service.MixinService;
+import org.tinylog.Logger;
+import space.vectrix.ignite.agent.IgniteAgent;
+import space.vectrix.ignite.launch.ember.EmberMixinContainer;
+import space.vectrix.ignite.launch.ember.EmberMixinService;
+import space.vectrix.ignite.launch.ember.EmberTransformer;
+import space.vectrix.ignite.launch.transformer.AccessTransformerImpl;
+
+/**
+ * Represents the mod loading engine.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class ModsImpl implements Mods {
+  private final ModResourceLocator resourceLocator = new ModResourceLocator();
+  private final ModResourceLoader resourceLoader = new ModResourceLoader();
+  private final Map<String, ModContainer> containers = new HashMap<>();
+  private final List<ModResource> resources = new ArrayList<>();
+
+  /**
+   * Creates a new mod loading engine.
+   *
+   * @since 1.0.0
+   */
+  public ModsImpl() {
+  }
+
+  @Override
+  public boolean loaded(final @NotNull String id) {
+    return this.containers.containsKey(id);
+  }
+
+  @Override
+  public @NotNull Optional<ModContainer> container(final @NotNull String id) {
+    return Optional.ofNullable(this.containers.get(id));
+  }
+
+  @Override
+  public @NotNull List<ModResource> resources() {
+    return Collections.unmodifiableList(this.resources);
+  }
+
+  @Override
+  public @NotNull Collection<ModContainer> containers() {
+    return Collections.unmodifiableCollection(this.containers.values());
+  }
+
+  /**
+   * Returns {@code true} if any mod resources were located, otherwise returns
+   * {@code false}.
+   *
+   * @return whether any mod resources were located
+   * @since 1.0.0
+   */
+  public boolean locateResources() {
+    return this.resources.addAll(this.resourceLocator.locateResources());
+  }
+
+  /**
+   * Returns a list of resolved mod container paths.
+   *
+   * @return resolved mod container paths
+   * @since 1.0.0
+   */
+  public @NotNull List<Map.Entry<String, Path>> resolveResources() {
+    final List<Map.Entry<String, Path>> targetResources = new ArrayList<>();
+    for(final ModContainerImpl container : this.resourceLoader.loadResources(this)) {
+      final ModResource resource = container.resource();
+
+      if(!resource.locator().equals(ModResourceLocator.LAUNCHER_LOCATOR) && !resource.locator().equals(ModResourceLocator.GAME_LOCATOR)) {
+        try {
+          IgniteAgent.addJar(container.resource().path());
+        } catch(final IOException exception) {
+          Logger.error(exception, "Unable to add container '{}' to the classpath!", container.id());
+        }
+      }
+
+      this.containers.put(container.id(), container);
+
+      final String prettyIdentifier = String.format("%s@%s", container.id(), container.version());
+      targetResources.add(new AbstractMap.SimpleEntry<>(prettyIdentifier, container.resource().path()));
+    }
+
+    return targetResources;
+  }
+
+  /**
+   * Resolves the access wideners provided by the mods.
+   *
+   * @param transformer the transformer
+   * @since 1.0.0
+   */
+  public void resolveWideners(final @NotNull EmberTransformer transformer) {
+    final AccessTransformerImpl accessTransformer = transformer.transformer(AccessTransformerImpl.class);
+    if(accessTransformer == null) return;
+
+    for(final ModContainer container : this.containers()) {
+      final ModResource resource = container.resource();
+
+      final List<String> wideners = ((ModContainerImpl) container).config().wideners();
+      if(wideners != null && !wideners.isEmpty()) {
+        for(final String widener : wideners) {
+          //noinspection resource
+          final Path path = resource.fileSystem().getPath(widener);
+          try {
+            Logger.trace("Adding the access widener: {}", widener);
+            accessTransformer.addWidener(path);
+          } catch(final IOException exception) {
+            Logger.trace(exception, "Failed to configure widener: {}", widener);
+            continue;
+          }
+
+          Logger.trace("Added the access widener: {}", widener);
+        }
+      }
+    }
+  }
+
+  /**
+   * Applies the mixin transformers provided by the mods.
+   *
+   * @since 1.0.0
+   */
+  public void resolveMixins() {
+    final EmberMixinService service = (EmberMixinService) MixinService.getService();
+    final EmberMixinContainer handle = (EmberMixinContainer) service.getPrimaryContainer();
+
+    for(final ModContainer container : this.containers()) {
+      final ModResource resource = container.resource();
+
+      handle.addResource(resource.path().getFileName().toString(), resource.path());
+
+      final List<String> mixins = ((ModContainerImpl) container).config().mixins();
+      if(mixins != null && !mixins.isEmpty()) {
+        Mixins.addConfigurations(mixins.toArray(new String[0]));
+        Logger.trace("Added the mixin configurations: {}", String.join(", ", mixins));
+      }
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/mod/package-info.java b/src/main/java/space/vectrix/ignite/mod/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9485b59ab2dfc70f597407444b2b66d221fbd21
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/mod/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the mod loading systems.
+ */
+package space.vectrix.ignite.mod;
diff --git a/src/main/java/space/vectrix/ignite/package-info.java b/src/main/java/space/vectrix/ignite/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a6ccb4cb7b846d2851934df661c3dbc636902c4
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains the entrypoint for Ignite.
+ */
+package space.vectrix.ignite;
diff --git a/src/main/java/space/vectrix/ignite/util/BlackboardMap.java b/src/main/java/space/vectrix/ignite/util/BlackboardMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8a6de4a32310a62ef6f98e24c33c31349fbfd3f
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/BlackboardMap.java
@@ -0,0 +1,175 @@
+package space.vectrix.ignite.util;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.UnknownNullability;
+
+import static java.util.Objects.requireNonNull;
+
+/**
+ * Represents a typed map.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class BlackboardMap {
+  /**
+   * Returns a new {@link BlackboardMap}.
+   *
+   * @return a new blackboard map
+   * @since 1.0.0
+   */
+  public static @NotNull BlackboardMap create() {
+    return new BlackboardMap();
+  }
+
+  private final Map<String, Key<Object>> keys = new ConcurrentHashMap<>();
+  private final Map<Key<Object>, Object> values = new ConcurrentHashMap<>();
+
+  private BlackboardMap() {
+  }
+
+  /**
+   * Returns the value associated with the given {@link Key}.
+   *
+   * @param key the key
+   * @param <V> the value type
+   * @return the value
+   * @since 1.0.0
+   */
+  public <V> @NotNull Optional<V> get(final @NotNull Key<V> key) {
+    requireNonNull(key, "key");
+    return Optional.ofNullable(key.type().cast(this.values.get(key)));
+  }
+
+  /**
+   * Sets the given value associated with the given {@link Key}.
+   *
+   * @param key the key
+   * @param value the value
+   * @param <V> the value type
+   * @since 1.0.0
+   */
+  public <V> void put(final @NotNull Key<V> key, final @Nullable V value) {
+    requireNonNull(key, "key");
+
+    if(value == null) return;
+    if(Objects.equals(key.defaultValue(), value)) {
+      this.values.remove(key);
+    } else {
+      this.put(this.values, key, value);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private <C1, C2, V> void put(final @NotNull Map<C1, C2> map, final @NotNull Key<V> key, final @NotNull V value) {
+    map.put((C1) key, (C2) value);
+  }
+
+  private @NotNull Map<String, Key<Object>> keys() {
+    return this.keys;
+  }
+
+  /**
+   * Represents a key for a {@link BlackboardMap}.
+   *
+   * @author vectrix
+   * @param <T> the value type
+   * @since 1.0.0
+   */
+  public static final class Key<T> implements Comparable<Key<T>> {
+    /**
+     * Returns a new blackboard key for the given {@link BlackboardMap}, with
+     * the given name and type.
+     *
+     * @param map the blackboard
+     * @param name the name
+     * @param type the type
+     * @param defaultValue the default value
+     * @param <V> the value type
+     * @return a new key
+     * @since 1.0.0
+     */
+    @SuppressWarnings("unchecked")
+    public static <V> @NotNull Key<V> of(final @NotNull BlackboardMap map, final @NotNull String name, final @NotNull Class<? super V> type, final @UnknownNullability V defaultValue) {
+      final Key<V> result = (Key<V>) map.keys().computeIfAbsent(name, key -> new Key<>(key, (Class<Object>) type, defaultValue));
+      if(result.type != type) throw new IllegalArgumentException("Mismatched type!");
+      return result;
+    }
+
+    private static final AtomicLong ID_GENERATOR = new AtomicLong();
+
+    private final long identifier;
+    private final String name;
+    private final Class<T> type;
+    private final T defaultValue;
+
+    private Key(final @NotNull String name, final @NotNull Class<T> type, final @UnknownNullability T defaultValue) {
+      this.identifier = Key.ID_GENERATOR.getAndIncrement();
+      this.name = name;
+      this.type = type;
+      this.defaultValue = defaultValue;
+    }
+
+    /**
+     * Returns the name.
+     *
+     * @return the name
+     * @since 1.0.0
+     */
+    public @NotNull String name() {
+      return this.name;
+    }
+
+    /**
+     * Returns the type.
+     *
+     * @return the type
+     * @since 1.0.0
+     */
+    public @NotNull Class<T> type() {
+      return this.type;
+    }
+
+    /**
+     * Returns the default value.
+     *
+     * @return the default value
+     * @since 1.0.0
+     */
+    public @UnknownNullability T defaultValue() {
+      return this.defaultValue;
+    }
+
+    @Override
+    public int hashCode() {
+      return (int) (this.identifier ^ (this.identifier >>> 32));
+    }
+
+    @Override
+    public boolean equals(final @Nullable Object other) {
+      if(this == other) return true;
+      if(!(other instanceof Key<?>)) return false;
+      final Key<?> that = (Key<?>) other;
+      return Objects.equals(this.identifier, that.identifier);
+    }
+
+    @Override
+    public String toString() {
+      return "Key{identifier=" + this.identifier + ", name=" + this.name + ", type=" + this.type + "}";
+    }
+
+    @Override
+    public int compareTo(final @NotNull Key<T> other) {
+      if(this == other) return 0;
+      if(this.identifier < other.identifier) return -1;
+      if(this.identifier > other.identifier) return 1;
+      throw new RuntimeException("Unable to compare the given key!");
+    }
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/util/ClassLoaders.java b/src/main/java/space/vectrix/ignite/util/ClassLoaders.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb7978103372002f153e375a2c04d1a71751ced2
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/ClassLoaders.java
@@ -0,0 +1,65 @@
+package space.vectrix.ignite.util;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.ArrayList;
+import org.jetbrains.annotations.NotNull;
+import org.tinylog.Logger;
+import sun.misc.Unsafe;
+
+/**
+ * Taken from <a href="https://github.com/cpw/grossjava9hacks/blob/1.3/src/main/java/cpw/mods/gross/Java9ClassLoaderUtil.java">grossjava9hacks</a>.
+ *
+ * @author cpw
+ * @since 1.0.0
+ */
+public final class ClassLoaders {
+  /**
+   * Returns the system class path {@link URL}s.
+   *
+   * @return the system class path urls
+   * @since 1.0.0
+   */
+  @SuppressWarnings({"restriction", "unchecked"})
+  public static URL@NotNull [] systemClassPaths() {
+    final ClassLoader classLoader = ClassLoaders.class.getClassLoader();
+    if(classLoader instanceof URLClassLoader) {
+      return ((URLClassLoader) classLoader).getURLs();
+    }
+
+    if(classLoader.getClass().getName().startsWith("jdk.internal.loader.ClassLoaders$")) {
+      try {
+        final Field field = Unsafe.class.getDeclaredField("theUnsafe");
+        field.setAccessible(true);
+        final Unsafe unsafe = (Unsafe) field.get(null);
+
+        // jdk.internal.loader.ClassLoaders.AppClassLoader.ucp
+        Field ucpField;
+        try {
+          ucpField = classLoader.getClass().getDeclaredField("ucp");
+        } catch(final NoSuchFieldException | SecurityException e) {
+          ucpField = classLoader.getClass().getSuperclass().getDeclaredField("ucp");
+        }
+
+        final long ucpFieldOffset = unsafe.objectFieldOffset(ucpField);
+        final Object ucpObject = unsafe.getObject(classLoader, ucpFieldOffset);
+
+        // jdk.internal.loader.URLClassPath.path
+        final Field pathField = ucpField.getType().getDeclaredField("path");
+        final long pathFieldOffset = unsafe.objectFieldOffset(pathField);
+        final ArrayList<URL> path = (ArrayList<URL>) unsafe.getObject(ucpObject, pathFieldOffset);
+
+        return path.toArray(new URL[0]);
+      } catch(final Exception exception) {
+        Logger.error(exception, "Failed to retrieve system classloader paths!");
+        return new URL[0];
+      }
+    }
+
+    return new URL[0];
+  }
+
+  private ClassLoaders() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/util/IgniteCollections.java b/src/main/java/space/vectrix/ignite/util/IgniteCollections.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d5c12060e01a4a2dafd7cddb75ffbdcd783f215
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/IgniteCollections.java
@@ -0,0 +1,43 @@
+package space.vectrix.ignite.util;
+
+import java.util.Iterator;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Provides static access to collection utilities.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class IgniteCollections {
+  /**
+   * Returns a {@link Stream} of the given {@link Iterable}.
+   *
+   * @param iterable the iterable
+   * @param <T> the type
+   * @return a stream
+   * @since 1.0.0
+   */
+  public static <T> @NotNull Stream<T> stream(final @NotNull Iterable<T> iterable) {
+    return StreamSupport.stream(iterable.spliterator(), false);
+  }
+
+  /**
+   * Returns the first element in the given {@link Iterator} or {@code null} if
+   * the iterator is empty.
+   *
+   * @param iterator the iterator
+   * @param <T> the type
+   * @return the first element if present
+   * @since 1.0.0
+   */
+  public static <T> @Nullable T firstOrNull(final @NotNull Iterator<? extends T> iterator) {
+    return iterator.hasNext() ? iterator.next() : null;
+  }
+
+  private IgniteCollections() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/util/IgniteConstants.java b/src/main/java/space/vectrix/ignite/util/IgniteConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..48f412ff962fcb0891079d9fe9cdb682025d8ae5
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/IgniteConstants.java
@@ -0,0 +1,58 @@
+package space.vectrix.ignite.util;
+
+import com.google.gson.Gson;
+import org.objectweb.asm.Opcodes;
+import space.vectrix.ignite.IgniteBootstrap;
+
+/**
+ * Provides static access to the constants.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class IgniteConstants {
+  /**
+   * The API name.
+   *
+   * @since 1.0.0
+   */
+  public static final String API_TITLE = IgniteBootstrap.class.getPackage().getSpecificationTitle();
+
+  /**
+   * The API version.
+   *
+   * @since 1.0.0
+   */
+  public static final String API_VERSION = IgniteBootstrap.class.getPackage().getSpecificationVersion();
+
+  /**
+   * The implementation version.
+   *
+   * @since 1.0.0
+   */
+  public static final String IMPLEMENTATION_VERSION = IgniteBootstrap.class.getPackage().getImplementationVersion();
+
+  /**
+   * The ASM version to use.
+   *
+   * @since 1.0.0
+   */
+  public static final int ASM_VERSION = Opcodes.ASM9;
+
+  /**
+   * The mod configuration file name.
+   *
+   * @since 1.0.0
+   */
+  public static final String MOD_CONFIG = "mixin-plugin.json";
+
+  /**
+   * The gson instance.
+   *
+   * @since 1.0.0
+   */
+  public static final Gson GSON = new Gson();
+
+  private IgniteConstants() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/util/IgniteExclusions.java b/src/main/java/space/vectrix/ignite/util/IgniteExclusions.java
new file mode 100644
index 0000000000000000000000000000000000000000..09c3910c2100eb5548a8a4151f71ecc71e8e2694
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/IgniteExclusions.java
@@ -0,0 +1,34 @@
+package space.vectrix.ignite.util;
+
+/**
+ * Provides static access to the transformation excluded paths and packages.
+ *
+ * @author vectrix
+ * @since 1.0.0
+ */
+public final class IgniteExclusions {
+  /**
+   * The resource paths excluded from transformation.
+   *
+   * @since 1.0.0
+   */
+  public static final String[] TRANSFORMATION_EXCLUDED_PATHS = {
+    "org/spongepowered/asm/"
+  };
+
+  /**
+   * The packages excluded from transformation.
+   *
+   * @since 1.0.0
+   */
+  public static final String[] TRANSFORMATION_EXCLUDED_PACKAGES = {
+    // Launcher
+    "com.astrafell.ignite.",
+
+    // Mixin
+    "org.spongepowered.asm."
+  };
+
+  private IgniteExclusions() {
+  }
+}
diff --git a/src/main/java/space/vectrix/ignite/util/package-info.java b/src/main/java/space/vectrix/ignite/util/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..f59b6ba00f7a0664155c4540df5de9c4c07dd68d
--- /dev/null
+++ b/src/main/java/space/vectrix/ignite/util/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This package contains implementation utility classes.
+ */
+package space.vectrix.ignite.util;
diff --git a/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService
new file mode 100644
index 0000000000000000000000000000000000000000..e4f4026b23cb372b20dc13e16d2961b93046ea43
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService
@@ -0,0 +1 @@
+space.vectrix.ignite.launch.MixinBlackboardImpl
diff --git a/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
new file mode 100644
index 0000000000000000000000000000000000000000..57fd9103981db6700ec85283003bb204229876c6
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
@@ -0,0 +1 @@
+space.vectrix.ignite.launch.ember.EmberMixinBootstrap
diff --git a/src/main/resources/META-INF/services/space.vectrix.ignite.game.GameLocatorService b/src/main/resources/META-INF/services/space.vectrix.ignite.game.GameLocatorService
new file mode 100644
index 0000000000000000000000000000000000000000..557ca6e63a48acd4c4a6eb41261dc40306f51f42
--- /dev/null
+++ b/src/main/resources/META-INF/services/space.vectrix.ignite.game.GameLocatorService
@@ -0,0 +1,5 @@
+space.vectrix.ignite.game.SpigotGameLocator
+space.vectrix.ignite.game.PaperGameLocator
+space.vectrix.ignite.game.VelocityGameLocator
+space.vectrix.ignite.game.LegacyPaperGameLocator
+space.vectrix.ignite.game.DummyGameLocator
diff --git a/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.EmberMixinService b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.EmberMixinService
new file mode 100644
index 0000000000000000000000000000000000000000..9ddb944da5c92dbc3c6e7ce863ddb7a7216db853
--- /dev/null
+++ b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.EmberMixinService
@@ -0,0 +1 @@
+space.vectrix.ignite.launch.ember.EmberMixinService
diff --git a/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.LaunchService b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.LaunchService
new file mode 100644
index 0000000000000000000000000000000000000000..b7871bad849799539321a782bef85166071467b1
--- /dev/null
+++ b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.LaunchService
@@ -0,0 +1 @@
+space.vectrix.ignite.launch.LaunchImpl
diff --git a/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.TransformerService b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.TransformerService
new file mode 100644
index 0000000000000000000000000000000000000000..5b62decba1be4c9a360f933e69cac017271cb8d1
--- /dev/null
+++ b/src/main/resources/META-INF/services/space.vectrix.ignite.launch.ember.TransformerService
@@ -0,0 +1,2 @@
+space.vectrix.ignite.launch.transformer.AccessTransformerImpl
+space.vectrix.ignite.launch.transformer.MixinTransformerImpl
diff --git a/src/main/resources/tinylog.properties b/src/main/resources/tinylog.properties
new file mode 100644
index 0000000000000000000000000000000000000000..aef552df921740aea8dfd9463b509fe1a22f90f1
--- /dev/null
+++ b/src/main/resources/tinylog.properties
@@ -0,0 +1,24 @@
+# https://tinylog.org/v2/configuration/
+# The launcher uses this to avoid any conflicts with Log4j used in the server environment
+writerConsole = console
+writerConsole.level = info
+writerConsole.format=[{date:HH:mm:ss}] [{thread}/{level}]: {message}
+
+writerFile = rolling file
+writerFile.level = info
+writerFile.format=[{date:HH:mm:ss}] [{thread}/{level}]: {message}
+writerFile.file = logs/launcher_{date:yyyy-MM-dd}-{count}.log
+writerFile.latest = logs/latest_launcher.log
+writerFile.charset = UTF-8
+writerFile.convert = gzip
+writerFile.policy = daily, startup
+
+writerDebug = rolling file
+writerDebug.level = trace
+writerDebug.format=[{date:HH:mm:ss}] [{thread}/{level}]: {message}
+writerDebug.file = logs/debug_launcher-{count}.log
+writerDebug.latest = logs/debug_launcher.log
+writerDebug.charset = UTF-8
+writerDebug.convert = gzip
+writerDebug.backups = 5
+writerDebug.policy = startup, size: 200mb
